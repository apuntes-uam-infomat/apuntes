\chapter{Algoritmos de factorización y tests de primalidad}

La base de la seguridad del sistema RSA es el hecho de que es fácil generar números primos grandes (por eso podemos usar el algoritmo) pero factorizar números grandes en factores primos es muy difícil.

A día de hoy, los ordenadores cuánticos serían capaces de factorizar primos a gran velocidad. En el momento en que estos ordenadores sean bastante grandes (con suficiente memoria) para operar con grandes números, el proceso de factorización será muy rápido, con lo que el algoritmo RSA dejará de ser seguro.

No obstante, vamos a seguir estudiando los procesos de factorización y primalidad desde el punto de vista de los ordenadores y los medios actuales.

Si quisiésemos factorizar un número, empleamos el algoritmo que usábamos en el colegio en el que vamos probando con todos los números primos. Es decir, empleamos la \textbf{criba de Eratóstenes}.

Para hacer esto, necesitamos tener una lista de todos los primos hasta $\sqrt{n}$ con los que ir probando. 

\begin{theorem}[Teorema del número primo]
El número de primos menores que un número $x$ es:
\[π(x) = O\left( \frac{x}{\log(x)}\right)\]
\end{theorem}

Una vez tenemos el número de primos existentes (cosa que en una situación real no se tiene pues $n$ es enorme), tendríamos que hacer un total $π(x)$ divisiones y, puesto que cada divisón nos supone $O(\log^3(n))$ bit-operaciones, tenemos que el total del algoritmo nos supone:
\[O(\log^3(n))\cdot O\left(\frac{\sqrt{n}}{\log(\sqrt{n})}\right) = O\left( e^{\frac{1}{2}\log(n)}\log^2(n)\right) \text{ operaciones }\]

\begin{example}
Supongamos que queremos factorizar un número del orden de $10^{75}$ empleando el ordenador mas rápido del punto.

El ordenador mas rápido del punto es capaz de realizar 33,86 PETAFLOPS, es decir, realizar un total de $33.86 \cdot 10^{15}$ operaciones por segundo.

Puesto que un año tiene $3,1537 \cdot 10^{7}$ segundos, tenemos que en un año podemos realizar, \textbf{con el ordenador más potente del mundo} un total de $10^{24}$ operaciones.

Suponiendo que cada división es una operación (que no es así), necesitaremos $10^{50}$ años para poder factorizar el número $10^{75}$.
\end{example}

\section{Test de primalidad}

Si queremos comprobar si un número es primo, no podemos depender de la factorización del mismo, puesto que entonces no podríamos comprobar la primalidad de números grandes. Para hacerlo nos apoyamos en el siguiente teorema.

\begin{theorem}[Teorema de Wilson (1770)]
\[n \text{ es primo } \iff (n-1)! = -1 \mod n\]
\end{theorem}
\begin{proof}
\begin{itemize}
\item $\Longleftarrow$

Supongamos que $n$ no es primo. Entonces tenemos difernetes casos: 
\begin{enumerate}
\item $n=n_1n_2$ con $1<n_1<n_2<n$

En este caso tenemos 
\[(n-1)!=1\cdot 2 ... \cdot n_1 \cdot ... n_2 \cdot ... = 0 \mod n\]

\item $n=p^2$ siendo $p$ primo impar

En este caso tenemos
\[(n-1)! = 1 \cdot 2 ... \cdot p ... \cdot 2p ... \cdot (n-1) = 0 \mod n\]

\item $n=4=2^2$

En esta ocasión
\[3! = 6 = 2 \mod 4\]
\end{enumerate}

\item $\implies$

Dado un elemento $a\in \ent_n$ tenemos:
\[a=a^{-1} \mod n \iff a^2 = 1 \mod n \iff a^2-1 = m \mod n\]

y la ecuación $a^2-1=0\mod n$ tiene, como mucho, dos raíces en un cuerpo. 

En este caso, estas raíces serían $a=1$, $a=(n-1)$.

Por tanto, puesto que estamos en $\ent_p$, todo elemento tiene su inverso por lo que al escribir $(n-1)!$ estamos multiplicando todos los elementos del cuerpo, por lo que cada factor tendrá estará multiplicado por su inverso y se cancelará, excepto $1$ y $(n-1)$ que son sus propios inversos.

Así nos queda:
\[(n-1)! \mod n = 1 \cdot (n-1) \mod n = n-1 \mod n = -1 \mod n\]
\end{itemize}
\end{proof}

Este algoritmo, aunque parece ``muy bonito'' no vale para nada, puesto que no factoriza (por tanto aporta menos información que la criba de Eratóstenes) y requiere calcular factoriales, lo que es muy costoso.

Sin embargo, en 2002 se desarrolló un algoritmo (AKS) capaz de comprobar si un número es primo en tiempo $O\left( \log^{12}(\log\log(n)^2\right)= \tilde{O}(\log^7(n))$.

Años más tarde, en 2006, se desarrolló un algoritmo capaz de hacer esto mismo en tiempo $\tilde{O}\left( \log^6(n)\right)$

Sin embargo, con el tamaño de números que trabajamos, el algoritmo AKS no es rentable, puesto que las constantes asociadas a la $O$ son demasiado elevadas.

\subsection{Tests probabilísticos}

Estos tests se basan en la afirmación filosófica de E. GJorel, que dice: ``Un suceso cuya probabilidad es de $10^{-50}$ o bien es imposible o nunca será observado''

Así estos test buscarán números que serán primos con probabilidad $1-10^{-50}$. Para esto necesitamos observar alguna propiedad de los números primos que sea fácilmente comprobable, para lo que emplearemos el pequeño teorema de Fermat.

\begin{theorem}[Pequeño teorema de Fermat]
Existen dos versiones de este teorema:
\begin{enumerate}
\item 
\[p \text{ primo } \implies \forall a \in \ent_p \ a^p=a \mod p\]

\item
\[p \text{ primo } \implies \forall a \in \ent_p \ a^{p-1}=1 \mod p\]
\end{enumerate}
\end{theorem}

\begin{defn}[Número pseudoprimo en base $a$]
Decimos que un número $p$ es pseudoprimo en base $a$ si se cumple que
\[a^{p-1}=1 \mod p \]
\end{defn}

Una vez visto esto podemos ver el lema en que se basan los test probabilísticos.
\begin{lemma}
Si existe $b_0$ coprimo con $n$ tal que $b_0^{n-1}\neq 1 \mod n$ (es decir, tenemos una prueba de que $n$ no es primo), entonces $b^{n-1} \neq 1 \mod n$ para, \textbf{al menos la mitad} de los $b$ posibles en $[1,n-1]$ coprimos con $n$.
\end{lemma}

Con este lemma, si $n$ no es primo, entonces $b^{n-1} \neq 1 \mod n$ con probabilidad mayor que $\frac{1}{2}$. Por tanto, si tomo al azar 200 valores $b$ y todos pasan el test, la probabilidad de que el número sea compuesto es menor que $\left( \frac{1}{2}\right)^{200} \approx \left(\frac{1}{10}\right)^{60}$

Veamos la demostración del lemma
\begin{proof}
Consideramos el conjunto de valores $\{a_1,...1_r\} \subset \left(\ent_n\right)^*$ tales que 
\[a_i^{n-1} = 1 \mod n\]

Entonces $n$ no es pseudoprimo en la bases $\{b_0a_1,...,b_0a_r\}$ ya que 
\[(b_0a_i)^{n-1} = b_0^{n-1}a_i^{n-1} = b^{n-1} \neq 1 \mod n\]
\end{proof}

Vamos a ver ahora cómo podríamos construir un test probabilístico de primalidad de manera incremental.

Empezamos considerando una versión \textbf{beta} del test.
\begin{enumerate}
\item Considero un número al azar $b \in [2,n-1]\cap \ent$
\item Compruebo si $b$ es coprimo con $n$ que, como ya vimos, es una tarea \textbf{fácil}
\begin{itemize}
\item Si $b$ no es coprimo con $n$ entonces $n$ no es primo, obviamente
\item Si $b$ es coprimo con $n$ calculo $b^{n-1} \mod n$ que también vimos que era una tarea \textbf{fácil}
\end{itemize}
\item Compruebo si $b^{n-1}$ es coprimo con $n$.
\begin{itemize}
\item Si $b^{n-1}\neq 1 \mod n$ entonces $n$ no es primo.
\item Si $b^{n-1} = 1 \mod n$ entonces $n$ podría ser primo. Volvemos al paso 1.
\end{itemize}
\end{enumerate}

Tras repetir el procedimiento 200 veces, si resulta que $n$ es pseudoprimo en las 200 bases, concluimos que $n$ es, \textbf{probabilísticamente primo}

Sin embargo, esta versión tiene un problema: \textbf{¿Qué ocurre si $n$ es pseudoprimo en todas las bases?}.

\subsection{Números de Carmichael}

\begin{defn}[Número de Carmichael]
Un \textbf{número de Carmichael} es un número compuesto tal que $b^{n-1}=1 \mod n$ para todo $b$ coprimo con $n$.
\end{defn}

Lo que nos interesa es comprobar si existen números de Carmichael (evidentemente existen, pues de lo contrario no hablaríamos de ellos), ver cuántos son y si existe alguna forma útil de caracterizarlos.

\begin{theorem}[Teorema de Korset (1899)]
Sea $n \in \ent$ son equivalentes:
\begin{enumerate}
\item \[b^n=b \mod n \ \forall b \in \ent\]
\item \[b^{n-1} = 1 \mod n \ \forall b \in \ent, \ t.q. \ (b,n)=1 \]
\item n es libre de cuadrados, es decir:
\[a^2|n \implies a = \pm 1 \text{ si p es primo } \neg p^2 | n\]
O lo que es lo mismo, si $p$ es primo y $p$ divide a $n$ entonces $p-1$ divide a $n-1$
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{itemize}
\item $1 \implies 2$

Sabemos que $(b,n)=1 \iff b \in\left(\ent_n\right)^*$. Por tanto, podemos multiplicar a ambos lados de la ecuación por $b^{-1}$ obteniendo:
\[b^n = b \mod n \implies b^{n-1}=1 \mod b\]

\item $3 \implies 1$

Sabiendo que $n$ es libre de cuadrados tenemos que:
\[b^n = b \mod n \iff b^n = b \mod p \ \forall p|n\]

\begin{proof}
Si $p|n$ entonces 
\[b^n = b \mod p \iff 0^n=0 \mod p \]

Por otro lado:
\[(b,p)=1 \implies b^n=bb^{n-1} = bb^{(p-1)k}=b\left(b^{p-1}\right)^k=b\mod p\]
\end{proof}

\item $2 \implies 3$

\begin{itemize}
\item[a)] Supongamos que $n$ no es libre de cuadrados, es decir, supongamos que existe un primo $p$ tal que $n=p^rn'$ siendo $r>2$ y $(n',p)=1$.

En estas condiciones tenemos
\[\left| \left(\ent_n\right)^*\right| = \varphi(p^r)=p^{r-1}(p-1) \implies p|\varphi(p^r)\]
donde la última implicación es válida puesto que $r>2$

Sabemos, por el teorema de Cauchy, que
\[\exists a \in \left(\ent_{p^r}\right)^* \tq ord(a)=p \text{ es decir } \left\{\begin{array}{l}a\neq 1 \mod p^r \\ a^p=1 \mod p^r \end{array}\right.\]

Por el teorema chino del resto, sabemos que existe un elemento $b \in \ent_n$ tal que:
\[\left\{\begin{array}{l}b=a\mod p^r \\ b=1 \mod n' \end{array}\right.\]

Por hipótesis tenemos que $b^{n-1}=1 \mod n$, por tanto:
\[b^{n-1} = 1 \mod p^r = a^{n-1} = 1 \mod p^r \implies ord(a) =p|n-1\]

\item[b)]
Tras llegar a la contradicción del apartado anterior sabemos que $n=p_1...p_r$ con $p_i \neq p_j$. Sea $p | n$ tenemos que $n=pn'$ con $(n',p)=1$.

Sabemos entonces que $(\ent_p)^*=<a>$ es cíclico.

Por el teorema chino del resto sabemos que 
\[\exists b \in (\ent_p)^* \tq \left\{\begin{array}{l}b=a\mod p \\ b=1 \mod n \end{array}\right.\] 

Si $n-1 = q(p-1)+r$ con $0 < r < p-1$ tenemos que $b^{n-1}=1 \mod n$ lo que implica que
\[b^{n-1}=1 \mod p \implies a^{n-1} = 1 \mod p \implies (a^{p-1})^qa^r = 1 \mod p \implies\]
\[\implies a^p = 1 \mod p \implies ord(a) = (p-1)|r<p-1 \implies r=0\implies p-1 | n-1\]
\end{itemize}
\end{itemize}
\end{proof}

Korset, con su teorema, dió un criterio para detectar números que fuesen primos en todas las bases. Sin embargo, nunca encontró un número que cumpliese estas propiedades y no fué hasta el año 1910 cuando Carmichael encontró que 561 es un número de Carmichael.

Otros ejemplos de números de Carmichael son 1105, 252601, 62745 y 9746347772161.

\begin{prop}
Todo número de Carmichael tiene, al menos, 3 factores primos distintos.
\end{prop}
\begin{proof}
Supongamos que tenemos un número de Carmichael $n=p\cdot q$, con $p<q$, que sólo tiene dos factores primos.

Entonces $q-1 | n-1$ pero $n-1 =pq-1=p(q-1)+p-1$ lo que implicaría que $q-1|p-1$ pero esto es imposible puesto que $p<q$.
\end{proof}

Si los números de Carmichael fuesen finitos podríamos hacer una lista con todos ellos de forma que al tratar de encontrar nuevos números primos si obtenemos uno de la lista podemos descartarlo directamente.

No obstante, \textbf{Alford-Gramville-Pomeanle} en 1994 demostraron que 
\[|\{c \tq \text{ c es de Carmichael y } c < x\}| > x^{2/7}\]
de donde se extiende que cuando $x$ tiende a infinito, tenemos infinitos números de Carmichael.

Con esto llegamos al gran problema del algoritmo probabilístico de factorización que hemos definido. El test da por válidos los números de Carmichael (que no lo son) y no tenemos forma de comprobar si el número obtenido es o no de Carmichael salvo aplicando el teorema de Korset, pero esto nos requiere factorizar.

\begin{example}
\textbf{Vamos a comprobar si 21 es un n'umero primo}.

Empezamos a aplicar nuestro algoritmo. Al azar tomamos $b=13$, que es coprimo con 21 y el test nos dice que:
\[13^{20} \mod 21 = (13^2)^{10} \mod 21 =1^{10} \mod 21 =1 \mod 21\]
con lo que hemos pasado el test.
\end{example}

Este ejemplo nos sirve para ilustrar una idea importante, que apareció en los parciales del año pasado. Si $a^2 = 1 \mod n$ sabemos que $n$ no es primo.

Si $n$ fuese primo tendr'iamos que $\ent_{n}$ sería un cuerpo y la ecuación $x^2-1 = 0 $ tendría exactamente dos soluciones en $\ent_{n}$ que son $x=\pm 1 = 1, n-1$.

Y es en esta idea en lo que se basará nuestro nuevo test de primalidad.

\subsection{Test de primalidad de Miller-Marsin (1974)}
\begin{defn}[Pseudoprimo fuerte en base $b$]
Sea $n \in \ent$ impar con $n>9$ y $n-1=r2^s$ siendo $r$ impar y $s \geq 1$, diremos que $n$ es \textbf{pseudoprimo fuerte} en base $b$ si $(n,b)=1$ y para algún $0 \leq i \leq s-1$ se cumple
\[b^{r2^i}=-1\mod n\]
\end{defn}

La idea de esta definición es que si $n$ es primo, tenemos:
\[(b^r)^{2^s} \mod n=b^{n-1} = 1 \mod n\]
y por tanto
\[(b^r)^{2^{s-1}} \mod n = \pm 1 \mod n\]
puesto que tiene que ser un número que, en el cuerpo $\ent_n$ tenga cuadrado igual a 1, por lo que sólo podría ser $\pm 1$

Si $(b^r)^{2^{s-1}}=-1$ satisface la condición inicial y lo declaro pseudoprimo fuerte. Si fuese $1$, repetimos el procedimiento.

Es decir, si $n$ es primo, entonces será pseudoprimo fuerte en toda base $b$ tal que $(b,n)=1$.
Pero esto no es más que una forma de caracterizar primos pero nosotros necesitamos justo lo contrario, a fin de poder determinar cuándo un número es primo o no.

\begin{theorem}
Si $n$ no es primo entonces no es pseudoprimo fuerte para al menos $\frac{1}{4}$ de los $b\in [1,n]$. Es decir, ``no hay números de Carmichael fuertes"
\end{theorem}

A partir de este teorema podemos desarrollar el \concept{Test de Miller-Marsin} de primalidad:
\begin{enumerate}
\item Elijo $b\in[1,n]$ de forma aleatoria y calculo $(b,n)$. Si el máximo común divisor es distinto de $1$, entonces hemos factorizado $n$ y por tanto $n$ no sería primo.
\item Si $(b,n)=1$ miro si $n$ es peudoprimo fuerte en base $b$. Si no lo es entonces $n$ no es primo
\item Si $n$ es pseudoprimo fuerte en base $b$ vuelvo al paso 1.
\end{enumerate}

Si repetimos el test $x$ veces, la probabilidad de que pasemos el tets todas esas veces es de $\left(\frac{3}{4}\right)^x$. Es decir, la probabilidad de decir que un número $n$ es primo sin serlo es de $\left(\frac{3}{4}\right)^x$.

Podemos ver que este algoritmo nos requiere calcular potencias de la forma $b^r \mod n$, que tiene un coste de $O(\log^4n)$. Tras esto tendremos que elevar al cuadrado estos valores de forma recurrente, necesitando $O(\log n)$ operactiones. 

Esta última potencia deberá calcularse unas $s=O(\log n)$ veces por lo que en total necesitaremos:
\[d\cdot O(\log^5 n)\text{ operaciones}\]
donde $d$ es lo bastante grande para que $\left(\frac{3}{4}\right)^d < \frac{1}{10^{50}}$

Si la \textbf{hipótesis de Riemann generalizada} es cierta tenemos que
\[n \text{ no es primo } \implies \exists b \in [1,n] \text{ t.q.} n \text{ no es pesudo primo fuerte en base } b\]

Entonces puedo probar todas las bases $b=2,3,4,...,2\log^2 n$.