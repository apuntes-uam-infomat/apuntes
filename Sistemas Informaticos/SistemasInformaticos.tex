\documentclass{apuntes}

\title{Sistemas Informaticos}
\author{Elena Gutiérrez y Pedro Valero}
\date{14/15 C1}

% Paquetes adicionales

% --------------------

\begin{document}
\pagestyle{plain}
\maketitle

\tableofcontents
\newpage
\setcounter{chapter}{1}
\chapter{Sistemas distribuidos basados en la WWW}

Las partes 1 y 2 de este tema se consideran demasiado triviales y se deja como ejercicio para el lector el leerse los apuntes y haber realizado las prácticas. (Son las que hablan del XML, XSL y esas cosillas).

\setcounter{section}{2}
\section{Web interactiva (Aplicaciones Web)}
El modelo de Web hipertexto no permite más iteracción del usuario que seleccionar la URL y comienza a hacerse necesario establecer comunicación entre programas del servidor con datos que proporciona el usuario, ya sea por medio de formularios (forms) o mediante la ejecución de programas en el propio servidor (Common Gateway Interface, CGI)

\subsection{CGIs}
\begin{defn}[CGI]
El CGI es un programa que recibe informacion de un servidor HTTP o WWW, de modo que permite al servidor ejecutar programas externos y recoger informacion que posteriormente enviara al cliente por medio de paginas HTML y el protocolo HTTP. 
\end{defn}

Esta tecnología de la World Wide Web (es una extensión del protocolo HTTP) permite que un cliente (el navegador) pueda solicitar los datos de un programa ejecutado en un servidor web. Fueron de los primeras métodos para crear contenido dinámico para las páginas web. El servidor web pasa las solicitudes del cliente a un programa externo, el CGI  (éste suele estar escrito en lenguaje script), y la salida de este programa es enviada al cliente en lugar del archivo estático tradicional.

\textbf{Forma esquemática de actualización de un CGI}
\begin{enumerate}
\item El servidor recibe una petición por parte del cliente que activa un URL que contiene el CGI
\item El servidor prepara el entorno para ejecutar la aplicación. La información necesaria procede en su mayoría del cliente (el formulario de entrada). EL servidor también envía a la aplicación, información de origen, URL que el usuario solicita, protocolo utilizado, etc. El paso de información a través del CGI se realiza mediante variables de entorno, línea de comandos y entrada y salida estándar (stdin y stdout). Los nombres de las variables de entorno pueden ser específicos del sistema. Hay diferentes tipos de variables de entorno:
\begin{itemize}
\item Variables de entorno independientes de la petición.
\item Variables de entorno dependientes de la consulta en cuestión
\item Variables de entorno relacionadas con la seguridad de acceso.
\item Variables de entorno sobre info adicionan de la consulta
\item Variables de entorno de la cabecera HTTP.
\end{itemize}
\item El  servidor ejecuta la aplicación y captura la salida estándar.
\item La aplicación realiza su función y como resultado va generando un objeto MIME que la aplicación escribe en su salida estándar.
\item El servidor envía la información producida junto con la información propia del cliente. Es responsabilidad de la aplicación informar del objeto MIME que se genera.

\end{enumerate}
\textbf{Importante} : Toda la comunicacion se realiza mediante el protocolo HTTP y el uso de páginas HTML, pues muestran el resultado de la ejecución del programa del CGI.



\subsubsection{Ventajas e inconvenientes}
\textbf{Ventajas:}
\begin{itemize}
\item Sencillez de programación.
\item Permite el uso de cualquier lenguaje de programación (normalmente PERL e interpretados)
\item El programa CGI no puede afectar al funcionamiento del servidor por ejecutarse como un proceso independiente.
\item Estándar, de modo que generaliza la portabilidad entre servidores de distintos fabricantes.
\end{itemize}
\textbf{Inconvenientes:}
\begin{itemize}
\item Lento. Cada ejecucion requiere iniciar un proceso y termianrlo: reservas de memoria, apertura de ficheros, conexiones a bases de datos...
\item Funciona por sesiones de modo que el programa CGI termina con cada llamada y no mantiene el estado de la comunicación entre peticiones.
\end{itemize}


\subsection{Formularios}
A continuacion, una breve introduccion a los formularios HTML :
\subsubsection{Protocolos}
HTTP + páginas HTML

\subsubsection{Funcionamiento básico}
\begin{enumerate}
\item El cliente solicita la página al servidor web.
\item El servidor envía una página que contiene el formulario.
\item El cliente lo rellena y lo devuelve al servidor.
\item El servidor, por la URL que el cliente solicita, ejecuta el programa al que pasa los datos recibidos del cliente.
\item El programa genera una página con los resultados de su ejecución y la devuelve al cliente a través del servidor web.
\end{enumerate}

\newpage
\subsubsection{Estructura y sintaxis}
La estructura de un formulario es la que sigue:
\begin{verbatim}
<FORM ACTION=url METHOD=método de envío>
  <INPUT> | <TEXTAREA> | <SELECT> | <BUTTON>
  otros elementos HTML
</FORM>
\end{verbatim}

Veamos con un poco más de detalle cuál es la función de cada campo del formulario:
\begin{itemize}
\item \textbf{Action:} Aquí se especifica la URL que se debe solicitar al enviar el formulario.
\item \textbf{Method:} Metodo de envio de los datos asociados al formulario. Pueden viajar asociados a la URL que se pide o en el cuerpo del mensaje HTTP.
\item Si \textbf{METHOD = GET} el mensaje HHTP es:
\begin{verbatim}
GET /logon?usuario=Superman&clave=loislane&nuevo=si
HTTP/1.1
(otras cabeceras HTTP)
(línea en blanco).
\end{verbatim}
\item Si \textbf{METHOD = POST}, el mensaje habría sido:
\begin{verbatim}
POST /logon HTTP/1.1
CONTENT-TYPE: application/x-www-form-urlencoded
CONTENT-LENGT: xxx
(otras cabeceras HTTP)
(línea en blanco)
usuario=Superman&clave=loislane&nuevo=s
\end{verbatim}
\end{itemize}
\textbf{Importante} La diferencia básica entre GET y POST radica en la forma en la que se envian los datos desde el cliente, una vez que este ha rellenado el formulario, al servidor.

Usando el metodo GET indicamos que los datos se envian usando la URL. Esta consta de la direccion web seguido del simbolo ? y a continuacion parejas de datos nombre y valor (ahora separado cada par por el simbolo \&) que corresponden con los parametros que han sido rellenados por el cliente. A veces, ciertos caracteres introducidos en el form son sustituidos por otros en la URL. No olvidemos que una URL es una ruta a un recurso en otra máquina de modo que tenemos restricciones en cuanto a los nombres de los ficheros y carpetas a los que accedemos.

Usando el metodo POST, la informacion introducida por el cliente en el form se puede decir que viaja oculta, pues no la podemos ver en la URL.

Comparando ambas: El método POST exige el uso de otras tecnicas, como el lenguaje que posteriormente estudiaremos, PHP para recuperar los datos que el cliente introdujo en el form, mientras que usando GET podemos extraerlos directamente de a URL. Por otra parte, la ventaja de usar POST es que los datos no son visibles al usuario de la web, de modo que, en el caso de usar GET el usuario es capaz de modificar los parametros a traves de la URL puediendo modificar la informacion que el servidor tratará.

\section{Web Application Programming Interfaces (Web APIs)}
\subsection{Introducción}
\begin{defn}[API]
Una \textbf{API} es una interfaz de programación de aplicaciones (del inglés API: Application Programming Interface). Es un conjunto de rutinas que provee acceso a funciones de un determinado software.
\end{defn}

Son publicadas por los constructores de software para permitir acceso a características de bajo nivel o propietarias, detallando sólamente la forma en que cada rutina debe ser llevada a cabo y la funcionalidad que brinda, sin otorgar información acerca de cómo se lleva a cabo la tarea. Son utilizadas por los programadores para construir sus aplicaciones sin necesidad de volver a programar funciones ya hechas por otros, reutilizando código que se sabe que está probado y que funciona correctamente.

En la web, las API's son publicadas por sitios (\emph{websites}) para brindar la posibilidad de realizar alguna acción o acceder a alguna característica o contenido que el sitio provee. Algunas de las más conocidas son las API's de: Google Maps, Amazon, Flickr, Google Search,...

Surgen para mitigar el bajo rendimiento de la interfaz CGI. En este caso, los nuevos programas se enlazan junto con el servidor en una librería dinámica, El servidor llama a las funciones de la librería como tareas dentro del proceso servidor. El proceso, en este caso, no finaliza: se mantienen ficheros abiertos, conexiones a base de datos y demás entre las llamadas. Se proporciona una API de acceso a datos y estado del servidor.

Presenta inconvenientes. Un fallo en una rutina hace que pueda caer el servidor completo. Se hace uso de lenguajes como C, C++, que en este aspecto están limitados. Dificil de programar, pues es necesario conocer el funcionamiento del servidor para aprovecharlas al máximo.

Algunos ejemplos: Netscape (NSAPI), Microsoft (ISAPI), IBM (ICAPI, GWAPI)...

\subsection{Interfaces Híbridas:}
Tratan de evitar los inconvenientes que veíamos de las CGIs y las Web APIs.
Los programas se realizan independientemente del servidor Web y en cualquier lenguaje.
El servidor durante la inicialización puede arrancar los programas en procesos diferentes.
Los programas se inicializan antes de recibir la petición, y quedan a la espera de recibirlas.

Ya no hay comunicación por medio de variables de entorno, Se utilizarán mecanismos de comunicación entre procesos más rápidos como acceso remoto mediante mecanismos de comunicación o bien empleando los mismos elementos que empleaban los CGIs para facilitar la migración de programas CGI a nuevas interfaces.
Es posible mantener el estado de la aplicación entre peticiones sucesivas y una vez que la petición es atendida, el programa vuelve a esperar otra petición.

\newpage
Ejemplos:
\begin{itemize}
\item FastCGI, de Open Market, Inc. Comunicación Servidor - Programas por Sockets.
\item Netscape Web Application Interface (WAI). Comunicación mediante CORBA.
\end{itemize}

\subsection{Páginas dinámicas:}
Se trata de extensiones del lenguaje HTML para permitir mayor capacidad de proceso. En el cliente (client side scripts) se lleva a cabo la inclusión de código que el cliente interpretará para variar dinámicamente la presentación de la página, proporcionando así “inteligencia” al navegador. En el servidor (server side scripts) se realiza una inclusión de código en el fichero que contiene la descripción de la página. De este modo, el servidor lo interpretará para variar la generación de la página antes de su envío al cliente.

Se trata de una alternativa a la programación CGI.

\section{El lenguaje PHP}
\subsection{Introducción}
Se trata de un lenguaje de programación basado en \emph{script} interpretado por el servidor. Presenta una sintaxis parecida a C y C++ y permite acceso a formularios, archivos, bases de datos, etc.

PHP es un lenguaje de script del lado del servidor (similar a otros lenguajes como ASP, JSP o Coldfusion). Sus siglas significan PHP Hypertext Processor.Los scripts PHP estan incrustados en el codigo HTML y el servidor los interpreta y ejecuta y transforma en HTML,  de modo que, el resultado que recibe el cliente no contiene código PHP. Es software abierto y gratuito, Para permitir el acceso a bases de datos, tenemos PHP + [PostgreSQL, MySQL], que es multiplataforma.


Para el acceso a información propia del servidor se utiliza un  array indexado con el nombre del parámetro al que se desea acceder. El nombre del array es \$\_SERVER[indice] donde índice puede ser: QUERY\_STRING, REMOTE\_HOST,....

Existen otros arrays indexados como \$\_REQUEST, para el acceso a variables asociadas a la petición recibida (campos de un formulario)
También existe \$\_SESSION que permite acceder a información de la sesión del usuario. El array \$\_REQUEST, tras una petición del cliente, incluye los contenidos de tres tipos de variables:
\begin{itemize}
\item \$\_GET Parámetros recibidos en un comando HTTP GET
\item \$\_POST Parámetros recibidos en un comando HTTP POST
\item \$\_COOKIES Lista de cookies recibidas con la petición.
\end{itemize}

Otras variables ya definidas son:
\begin{itemize}
\item\$\_FILES
\item\$\_ENV
\item\$\_GLOBALS
\end{itemize}


\subsection{Características del lenguaje}

\begin{verbatim}
$variable : Permite declarar variables. (Recuerda: es case sensitive). Ha de
 comenzar por letra o _ y después letras, números o _ (Recordemos el examen
  de AUTLEN). En  cuanto a su ámbito, son globales al fichero, excepto si
   aparecen en una función , que son locales.


echo $variable1 . $variable2: Permite concatenar cadenas e imprimirlas.


echo strpos("Hello world!","world") : Devuelve la posición en la que
 comienza la cadena que es el segundo argumento.


echo strlen("Hello world!");: Devuelve la longitud de la cadena (no cuenta /0)
\end{verbatim}



Veamos un ejemplo de declaración de una función:
\begin{verbatim}
function functionName()
{
  code to be executed;
}
\end{verbatim}

Ejemplo de declaración y uso de arrays:
\begin{verbatim}
$cars=array("Saab","Volvo","BMW","Toyota");
<?php
  $cars[0]="Saab";
  $cars[1]="Volvo";
  $cars[2]="BMW";
  $cars[3]="Toyota";
  echo $cars[0] . " and " . $cars[1] . " are Swedish cars.";
?>
\end{verbatim}
Resultado: Saab and Volvo are Swedish cars.

Ejemplo de declaración y uso de arrays \textbf{ASOCIATIVOS}
\begin{verbatim}
$ages = array("Peter"=>32, ”Mike"=>30, "Joe"=>34);
<?php
  $ages['Peter'] = "32";
  $ages['Mike'] = "30";
  $ages['Joe'] = "34";
  echo "Peter is " . $ages['Peter'] . " years old.";
?>
\end{verbatim}
Resultado: Peter is 32 years old.

\subsection{Tipos de datos en PHP}
PHP soporta 8 tipos de datos primitivos:
\begin{itemize}
\item Escalares: boolean, integer, double y string.
\item Compuestos: Array y object
\item Especiales: resource y NULL.
\end{itemize}
El tipo de dato no se suele especificar, sino que es en tiempo de ejecución cuando se determina en función del contexto. En este aspecto, algunas funciones interesantes son:
\begin{itemize}
\item gettype() que devuelve el tipo de una variable.
\item istype() por ejemplo: is\_array(), is\_float(), is\_null(), is\_numeric(), is\_scalar()..
\item var\_dump() muestra tipo y valor de una variable (interesa cuando usamos arrays).
\end{itemize}

\subsubsection{String}
Las cadenas pueden parecer entre comillas simples o dobles:
\begin{verbatim}
- Simples: admiten caracteres de escape como \’ (comilla simple) y \\ (barra).
Las variables no se expanden (es decir: ‘a vale $a’ muestra “a vale $a”)
- Dobles: admiten más caracteres de escape como \n, \r, \t, \\, \$, \”. En
 este caso, las variables sí se expanden: “a vale 9”
\end{verbatim}

Para acceder a un carácter de la cadena usamos: \$letra = \$cadena\{8\};

\textbf{Nota sobre la diferencia entre echo y print}:
Ambas permiten imprimir con salida en el fichero HTML que el servidor genera. ¿La diferencia? Son basicamente 2:
\begin{itemize}
\item echo es más rapido pues no devuleve un valor a diferencia de print
\item echo acepta el formato : echo expresion, [expresion], [expresion] mientras que print solo acepta el formato print([expresion]).
\end{itemize}
\textbf{Nota}: PHP es mas eficiente en el parseo de código si usamos comillas simples en lugar de dobles cuando la cadena que deseamos imprimir no contiene variables.



\subsubsection{Constantes}
Se definen así:
\begin{verbatim}
define (“CONSTANTE”, “hola); es decir define (“NOMBRE“, “valor”).
\end{verbatim}
No llevan \$ delante y solo se pueden definir constantes de tipo escalar: boolean, integer, string y double.

\newpage
\subsection{Funciones: Paso por referencia}
Si no indicamos nada los parámetros se pasan por valor.

Ejemplo:
\begin{verbatim}
function incrementa (&$a)
{
  $a = $a + 1;
}
$a=1;
incrementa ($a);
print $a; // Muestra un 2
\end{verbatim}

Ejemplo de función y array:

\begin{verbatim}
<HTML>
<HEAD>
  <TITLE>Fecha</TITLE>
  <?PHP
    // Función que obtiene el nombre de un mes
    function nombreMes ($mes)
    {
      $meses = array ("enero", "febrero", "marzo", "abril", "mayo",
      "junio", "julio", "agosto", "septiembre",
      "octubre", "noviembre", "diciembre");
      $i=0;
      $enc=false;
      while ($i<12 and !$enc)
      {
        if ($i == $mes-1)
        $enc = true;
        else
        $i++;
      }
      return ($meses[$i]);
    }
  ?>
</HEAD>
<BODY>
  <H1>Tablas y funciones</H1>
  <?PHP
    $dia = date ("j");
    $mes = date ("n");
    $anyo = date ("Y");
    print ("Hoy es " . $dia . " de " . nombreMes($mes) .
    " de " . $anyo . "<BR>\n");
  ?>
</BODY>
</HTML>
\end{verbatim}

\subsection{HTML + PHP: Formularios}
Si declaramos en el html un elemento form con el campo method = “GET” entonces en el código php (incluido en otro fichero a parte) debemos acceder a los campos input mediante: GET[“atributo”] donde “atributo” es el valor del campo name del elemento input.

Particularidades:
\begin{enumerate}
\item Si “atributo” era type = “text” : \$atributo = GET[“atributo”] guardará el texto que introdujimos.

\item Si “atributo” era type = “radio” : Haremos \$atributo = GET[“atributo”] que guardara el campo value de la opción que hayamos pinchado.

\item Si “atributo” era type = “checkbutton”  y por tanto name= valores[]: Haremos \$valores = GET[“valores”] que guardará en forma de array los valores que han sido marcados (y por tanto la longitud del array será igual al número de “tics” que hayan sido marcados). Podemos imprimirlos así:
\begin{verbatim}
$valores= $_GET['valores'];
$n = count ($valores);
for ($i=0; $i<$n; $i++)
  print ("$valores[$i]<BR>\n");
\end{verbatim}
y solo se imprimirán aquellos campos “value “ de los que fueron marcados.

\item Si “atributo” era de type=“button” guardaremos en \$atributo=\$\_GET[“atributo”] true or false (no se si eso exactamente pero el equivalente a esto en php). De este modo, tiene sentido poner:
\begin{verbatim}
if ($actualizar)
  print("Se han actualizado los datos");
\end{verbatim}
%\begin{obs} Este tipo no funciona igual que “submit”. En este último caso, podemos acceder al .php al que asociamos el formulario, sin embargo escribiendo button, aun poniendo la url en el campo action de form, no funciona?
%\end{obs}

\item Podemos usar de manera análoga: password, <SELECT AREA>, <SELECT MULTIPLE> <TEXTAREA>

\item Importante:
Una de las ventajas de PHP es que se puede procesar y mostrar el formulario desde un mismo .php. La estructura debe ser la siguiente:
\begin{verbatim}
si se ha enviado el formulario:
  si hay errores:
    Mostrar formulario con errores
  si no:
    Procesar formulario
si no:
  Mostrar formulario
\end{verbatim}
La clave para que esto funcione es en el formulario indicar que el campo action es el mismo php que en el que nos encontramos. Además para comprobar que se ha pulsado o no el botón de submit, debemos usar la condición:
if (isset(\$aceptar)) o bien if (\$aceptar==”Aceptar”) donde el elemento HTML tiene la forma:
\begin{verbatim}
<INPUT TYPE="SUBMIT" NAME="aceptar" VALUE="Aceptar">
\end{verbatim}

Para ver un ejemplo, mirar el ejercicio que se pidió subir a moodle.
\end{enumerate}

\subsection{Cookies}
Se trata de un pequeño fichero que el servidor introduce en el pc del cliente (con el permiso de su navegador). Cada vez que el navegador solicite una nueva página  a ese servidor, le enviará también la cookie.

\subsubsection{Sintaxis}
Se coloca antes de la etiqueta <html>
\begin{verbatim}
<?php
	setcookie("user", ”Bob Sponge", time() + 60 * 60);
?>
<html>
...
\end{verbatim}

La variable \$\_COOKIE es un array que guarda (name,value, expire, path, domain) que son los campos que se introducen en la función setcookie. Esta información es la que viaja en un fichero cada vez que se produce una comunicación entre el servidor y el cliente.

Para imprimirlos:

\begin{verbatim}
echo $_COOKIE[“user”];
\end{verbatim}
Para ver todas:
\begin{verbatim}
print_r($_COOKIE);
\end{verbatim}
Para verificar que una en concreto existe:
\begin{verbatim}
if(isset($_COOKIE[“user”]))....
\end{verbatim}

\subsection{Sesiones}
Por último, en PHP encontramos una variable que es \$\_SESSION que guarda valores relativos a la sesión que se tiene abierta. Es útil cuando el servidor quiere llevar el rastro del usuario durante un tiempo finito, por ejemplo, cuando el cliente visita varios lugares de un supermercado añadiendo productos a un carrito de la compra.

\subsubsection{Sintaxis}
Algunas de las funciones más importantes son:
\begin{itemize}
\item \textbf{session\_start()}; Comienza la sesión o la reanuda si ya existía.
\item \textbf{\$\_SESSION[‘name’] = “Elena”}; Establece el nombre o identificador  de la sesión
\item \textbf{unset(\$\_SESSION[‘name])}; Borra el identificador del usuario (elimina una única variable del array \$\_SESSION). Esta funcion puede ser aplicada a otras variables previamente declaradas en nuestro código y su comportamiento es destruir dicha variable. Ojo, si la variable en cuestión es global y llamamos a unset() dentro de una función, solo la variable local sera destruida.

 Otro ejemplo:
unset(\$\_SESSION['session\_var']);

\item \textbf{session\_unset()}; Borra los contenidos de la sesión pero mantiene el id y el nombre de la sesión.
\item \textbf{session\_destroy()}; Elimina la sesión (no sólo los datos que fueron guardados en la misma). Sería lo conveniente, cuando, por ejemplo, un usuario decide hacer \emph{log out} en una página web.
\end{itemize}

\section{Ejecución de código en el cliente: Javascript, AJAX y JQuery}

\subsection{Javascript}
\subsubsection{Introducción}
Es un lenguaje de programación interpretado, dialecto del estándar ECMAScript desarrollado por Netscape en colaboración con Sun. Se define como orientado a objetos, basado en prototipos, imperativo, débilmente tipado y dinámico.

Se utiliza principalmente en su forma del lado del cliente (client-side), implementado como parte de un navegador web permitiendo mejoras en la interfaz de usuario y páginas web dinámicas aunque existe una forma de JavaScript del lado del servidor (Server-side JavaScript o SSJS). 

JavaScript se diseñó con una sintaxis similar al C (permite la creación e invocación de rutinas en HTML ), aunque adopta nombres y convenciones del lenguaje de programación Java. Sin embargo Java y JavaScript no están relacionados y tienen semánticas y propósitos diferentes.

Todos los navegadores modernos interpretan el código JavaScript integrado en las páginas web. Para interactuar con una página web, se provee al lenguaje JavaScript de una implementación del Document Object Model(DOM).
JavaScript se interpreta en el agente de usuario, al mismo tiempo que las sentencias van descargándose junto con el código HTML.

\subsubsection{Aplicaciones}
 Su uso en aplicaciones externas a la web, por ejemplo en documentos PDF, aplicaciones de escritorio (mayoritariamente widgets) es también significativo. En cuanto a las más significativas:
\begin{itemize}
\item Inclusión de adornos y efectos visuales en textos e imágenes 
de las páginas web
\item Manipulación de contenidos de forma dinámica
\item Realización de operaciones matemáticas sencillas
\item Validación de datos introducidos en formularios
\item Gestión del sistema de navegación (menús desplegables)
\item Control del tipo y versión del navegador web, uso de la fecha y 
hora actuales, verificación de plugins…
\end{itemize}
Además proporciona objetos para manejar un documento HTML:
\begin{itemize}
\item Window \item Document \item Frame \item Location  \item Navigator \item History \item Button  \item Textarea \item Radio
\end{itemize}
Junto con funciones para capturar  eventos
\begin{itemize}
\item onClick \item onChange \item onFocus \item onLoad \item onMouseOver \item onSelect
 \end{itemize}
\subsubsection{Características}
Está enfocado al manejo de elementos de documentos HTML y el navegador web, minimizando el trasiego de datos entre el cliente y el servidor.

Permite realizar tareas sencillas que no requieren mucha más información que la proporcionada por el usuario a través del propio documento HTML sobre el que se ejecuta. No se compila sino que es \textbf{interpretado por el navegador} y aparece insertado en el código HTML.

Por comodidad, el código suele escribirse en la cabecera del docuemto HTML o en un fichero aparte, que será enviado junto con el HTML ante la solicitud de un cliente.

Es case-sensitive y las sentencias se terminan mediante ; o salto de línea.
\subsubsection{Variables}
\begin{enumerate}
\item Son 'no tipadas', es decir, no se declara el tipo de dato y, además, puede cambiar a lo largo de la ejecución de un programa.

Ejemplo:

\begin{verbatim}
x = 2 // El tipo de datos de x es entero, pero no se declara
x = "hola" // El tipo de x se puede cambiar
\end{verbatim}
\item Las variables son globale por defecto. Para declararlas locales:
\begin{verbatim}
var x;
 \end{verbatim}
\item Otros ejemplos:

\begin{verbatim}
x = 1.7 // Número
x = "hola" // Cadena de caracteres
x = 'hola' // Cadena de caracteres
x = 'hola ' + 'mundo' // Concatenación de cadenas de caracteres
x = true // Booleano
x = null // Literal nulo
x = [2, 3, 5, "Alice"] // Array, x[0], x[1], x[2], x[3]
x = \{ a:2, b:'Bob' \} // Array asociativo, x['a'], x['b']
\end{verbatim}
\end{enumerate}
\subsubsection{Objetos}
En este aspecto es muy similar a Java. Cada objeto consta de \textbf{ propiedades +  métodos ( + eventos)}. 
\begin{enumerate}
\item Propiedades
\begin{itemize}
\item Son las características (atributos y elemntos) de un objeto. 
\item Las propiedades pueden ser a su vez objetos. 
\item Para crear nuevos objetos y sus propeidades:
\begin{verbatim} 
 profesor = new Object(); 
profesor.nombre = ”Kowalski";
\end{verbatim}
\item Para acceder a sus propiedades una vez creadas:
\begin{verbatim} 
unaCadena.length; 
window.document;
\end{verbatim}
\end{itemize}

\item Métodos: 
\begin{itemize}
\item Son funcionalidades de las que consta un objeto.
\item Ejemplos:
\begin{verbatim} 
 unaCadena.substring(2);
 window.write('<p>Hola mundo</p>’);
\end{verbatim}

\end{itemize}
\item Eventos
\begin{itemize}
\item Son acciones que ocurren  en la interfaz gráfica sobre un objeto de la misma:
\begin{itemize}
\item Llevadas a cabo por el usuario (click del ratón o pulsación de una tecla,...) o,
\item Asociadas al documento (carga del contenido o maximixación/minimización de la ventana,... )
\end{itemize}
\item Desatan la ejecución de métodos.
\item Ejemplos:
\begin{verbatim} 
<input type="button" onClick="window.alert('¡Botón pulsado!')">
\end{verbatim}
\end{itemize}


En JavaScript existe un objeto llamado document, que engloba todo el fichero html. De él cuelgan a modo de árbol los diferentes elementos del documento:
\begin {itemize}
\item Layer
\item Link
\item Image
\item Area
\item Anchor
\item Applet
\item Plugin
\item Form
\end{itemize}
En particular, dentro de la clase Form de document encontramos las subclases:

\begin{itemize}
\item Textarea
\item Text
\item FileUpload
\item Password
\item Hidden
\item Submit
\item Reset
\item Radio
\item Checkbox
\item Button
\item Select
\end{itemize}

De este modo, un botón definido así:

\begin{verbatim}
<INPUT id=“botón submit" type="submit" >
\end{verbatim}
puede ser identificado en Javascript de las siguientes maneras:

document.forms[0].elements[3] (si es el cuarto elemento dentro de un formulario en HTML).

document.getElementById("botón submit")

document.getElementByTagName("input")[2]



\end{enumerate}

\subsection{Incorporacion de código Javascript en documentos HTML}

La integración de Javascript y HTML en el diseño de páginas web se puede hacer de 3 maneras:

\begin{enumerate}
\item Como código directo en el cuerpo de un documento HTML.
\item Incorporación de funciones en la cabecera del documento HTML.
\item Incorporación de código en forma de fucniones en un fichero de texto independiente (.js).
 
\end{enumerate}


A continuación presentamos un ejemplo de cada una de estras 3 modalidades:

1. Ejemplo de código directo:

\begin{verbatim}
<HTML>
<HEAD>
</HEAD>
<BODY>
<SCRIPT type="text/javascript">
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++) \{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
</SCRIPT>
</BODY>
</HTML
\end{verbatim}

3. Ejemplo de código en la cabecera de un documento HTML:

\begin{verbatim}
<HTML>
<HEAD>
<SCRIPT type="text/javascript">
function mostrarTitulos() \{
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++) \{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
\}
</SCRIPT>
</HEAD>
<BODY>
<INPUT type="button" value="Mostrar" onClick="mostrarTitulos()">
</BODY>
</HTML>
\end{verbatim}

1. Ejemplo de código en un fichero.js independiente:
En el documento HTML:
\begin{verbatim}
<HTML>
<HEAD>
<SCRIPT src="mostrar-titulos.js"></SCRIPT>
</HEAD>
<BODY>
<INPUT type="button" value="Mostrar" onClick="mostrarTitulos()">
</BODY>
</HTML>

\end{verbatim}

En el fichero independiente .js:
\begin{verbatim}
function mostrarTitulos() \{
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++)\{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
\}
\end{verbatim}

\textbf{Nota:} Los ejemplos 1-7 se dejan como ejercicios para el lector.

Para acabar con la sección del lenguaje Javascript, es importante saber que no todos los navegadores reconocen Javascript a día de hoy, veáse las versiones antiguas de nuestro navegador favorito : Internet Explorer. Es por tanto, útil el uso del siguiente comentario en nuestros códigos Javascript para evitar que el código sea mostrado como parte del contenido de la página.

\begin{verbatim}
<html>
<body>
<script type="text/javascript">
<!--
document.getElementById("demo").innerHTML=Date();
//-->
</script>
</body>
</html>
\end{verbatim}

Damos comienzo a una nueva sección con las vertientes que surgieron a Javascript: \textbf{DHTML, AJAX y JQuery}. 

\subsection{DHTML }
Con el objetivo de aumentar la interactividad y la creatividad en las páginas web surgió DHTML. Se trata de un término que engloba una serie de tecnologías diseñadas para el enriquecimiento de las páginas web usando una combinación de lenguajes “etiquetados”, como por ejemplo, HTML; lenguaje de scripting del lado del cliente, como por ejemplo, Javascript; lenguaje de definición de estilo, como por ejemplo, CSS; y Document Object Model, esto es, DOM (se trata de un lenguaje independiente que permite la creación e interacción con objetos  HTML, XML, y  XHTML. Los nodos de este tipo de documentos se estructuran en forma de árbol recibiendo la estructura,  el nombre de DOM tree).


\subsection{AJAX}
Con fines de eficiencia y mejora de la usabilidad de las páginas web nace AJAX. 

\emph{Standing for} Asynchronous Javascript and XML, no se trata de un nuevo lenguaje de programación sino de una nueva forma de usar  la tecnología que disponemos. Se trata de una nueva técnica de desarrollo web para crear aplicaciones interactivas del lado del cliente o RIA (Rich Internet Applications), manteniendo comunicación asíncrona con el servidor en un segundo plano. Alcanzó popularidad con Google y actualmente permiten su uso Mozilla, Mozilla Firefox, navegadores basados en Webkit (¿Qué es esto? es una plataforma para aplicaciones que funciona como base para navegadores  navegador web Safari, Google Chrome entre otros) como Google Chrome de Google o Safari, Microsoft Internet Explorer  y superiores...

\textbf{¿Qué se gana con esto?}
Poder realizar cambios sobre las páginas sin necesidad de recargarlas mejorando así la interactividad, velocidad y usabilidad de las páginas web.

Es una tecnología asíncrona en el sentido de que los datos adicionales se solicita al servidor y se cargan en segundo plano sin interferir en la visualización ni el comportamiento de la página. JavaScript es el lenguaje interpretado (scripting language) en el que normalmente se efectúan las funciones de llamada de Ajax mientras que el acceso a los datos se realiza mediante XMLHttpRequest, objeto disponible en los navegadores actuales. En cualquier caso, no es necesario que el contenido asíncrono esté formateado en XML.
Ajax es una técnica válida para múltiples plataformas y utilizable en muchos sistemas operativos y navegadores dado que está basado en estándares abiertos como JavaScript y Document Object Model (DOM).

\textbf{¿Cómo funciona?}
Combina estándares de Internet:

– XMLHttpRequest object (¿Y esto qué es? es una interfaz empleada para realizar peticiones HTTP y HTTPS a servidores Web. Para los datos transferidos se usa cualquier codificación basada en texto, incluyendo: texto plano, XML, JSON, HTML y codificaciones particulares específicas. La interfaz se implementa como una clase de la que una aplicación cliente puede generar tantas instancias como necesite para manejar el diálogo con el servidor. Se trata del objeto clave para realizar las comunicaciones con el servidor desde un segundo plano  sin necesidad de recargar las páginas. Este objeto depende de cada navegador, teniendo una implementación y comportamiento distinto en navegadores obsoletos como Internet Explorer 6 y anteriores. Para su creación usamos los métodos: 
xmlhttp=new XMLHttpRequest();
xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");

– JavaScript/DOM
– CSS
– XML
Además las aplicaciones AJAX no dependen del navegador ni de la plataforma que utilicemos.



\subsubsection{Ventajas e Inconvenientes de AJAX}
\begin{enumerate}
\item Cuando realizamos varias peticiones sucesivas de AJAX y con ello creamos nuevas páginas dinámicas, éstas no son registradas de forma automática en el historial de nuestro navegador de modo que si pulsamos atrás el usuario no regresa a la página anterior con el estado anterior sino que puede ser llevado a la última página que visitó.

 ¿Solución? 

Incluir el uso de Iframes ( ¿Qué es esto?  Se trata de un elemento HTML que permite insertar o incrustar un HTML dentro de otro principal y que ya es aceptado por la W. Comparando con AJAX, este último hace que cada parte de un documento HTML sea independiente) para desencadenar cambios en el historial del navegador y e l cambio de la porción de anclaje de la dirección (después de un \#).

\item Dependiendo de cómo  se desarrolle el sitio web puedes mejorar o empeorar la carga en el servidor. Ajax puede ayudar al servidor a evitar la  generación de HTML, dejándole ese trabajo al cliente, pero también puede sobrecargar al servidor si se hacen varias llamadas a Ajax.

\item Es posible que AJAX no funcione en teléfonos móviles y otros dispositivos.

\end{enumerate}
\subsubsection{Ejemplo de funcionamiento}
\small
\begin{verbatim}
<html>
  <head>
    <script type="text/javascript">
      function loadXMLDoc() {
        var xmlhttp;
         if (window.XMLHttpRequest) {
          // code for IE7+, Firefox, Chrome, Opera, Safari
          xmlhttp=new XMLHttpRequest();
         }
        else {
          // code for IE6, IE5
          xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
      }
\end{verbatim}
\normalsize
Con esto hemos creado el objeto XMLHttpRequest mencionado anteriormente.
\small
\begin{verbatim}
      xmlhttp.onreadystatechange=function() {
        if (xmlhttp.readyState==4 && xmlhttp.status==200){
          document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
        }
\end{verbatim}
\normalsize
Se recoge la respuesta
\small
\begin{verbatim}
      }
      xmlhttp.open("GET","ajax_info.txt",true);
      xmlhttp.send();
\end{verbatim}
\normalsize
Enviamos la petición al servidor
\small
\begin{verbatim}
      }
    </script>
  </head>
  <body>
    <div id="myDiv"><h2>Let AJAX change this text</h2></div>
    <button type="button" onclick="loadXMLDoc()">Change Content</button>
\end{verbatim}
\normalsize
Al pulsar el botón se ejecuta la función 'loadXMLDoc()'
\small
\begin{verbatim}
  </body>
</html>
\end{verbatim}

\subsubsection{Objeto XMLHttpRequest}
\begin{defn}[Objeto XMLHttpRequest]
(XHR), también referida como XMLHTTP (Extensible Markup Language / Hypertext Transfer Protocol), es una interfaz empleada para realizar peticiones HTTP y HTTPS a servidores Web. Para los datos transferidos se usa cualquier codificación basada en texto, incluyendo: texto plano, XML, JSON, HTML y codificaciones particulares específicas. La interfaz se implementa como una clase de la que una aplicación cliente puede generar tantas instancias como necesite para manejar el diálogo con el servidor.
\end{defn}
Es soportado por todos los navegadores modernos salvo IE5 e IE6 que emplean ActiveXObjetc. Esto cause que necesitemos poner un if en el ejemplo anterior con el fin de funcionar sobre cualquier navegador.

Se emplea para intercambiar datos con el servidor detrás de la escena, mientras la página web sigue funcionando normalmente. Esto es lo que permite actualizar parcialmente una página web.

En el ejemplo se observan dos métodos empleados sobre el objeto (además del creador):
\begin{itemize}
\item \textbf{xmlhttp.open}
Especifica el tipo de petición (GET o POST), la URL y si la petición debe atenderse de forma asíncrona o no.
\item \textbf{xmlhttp.send}
Envía la petición al servidor. Sólo recibe argumentos en caso de que la petición sea de tipo POST
\end{itemize}

Tras realizar la petición es necesario \textbf{recoger la respuesta}. La forma de hacerlo varía según la forma en que se intercambie la información.

Si es asíncrono se emplea la función: 'xmlhttp.onreadystatechange=function()', que implica que en cuanto se reciva la información solicitada se invoque a la función indicada.

Si es síncrono se coloca el código justo después del 'send', que quedará esperando la respuesta.

Si la codificación está basada en XML nos apoyamos en la propiedad 'responseXML', que contiene el contenido de la respuesta del servidor en formato XML.

Sin embargo, si la codificación es por medio de texto plano, nos debemos apoyar en la propiedad 'responseText' que contiene la respuesta del servidor en forma de cadena de texto.

\subsection{JQuery}
Es una biblioteca de JavaScript, creada inicialmente por John Resig, que permite simplificar la manera de interactuar con los documentos HTML, sobre todo facilita  el trabajo en el cliente con el DOM de una manera legible y más fácil. Además facilita los siguientes aspectos:
\begin{itemize}
\item Acceso a la estructura del documento (esto es lo que mencionábamos respecto a la facilidad de trabajar con el árbol DOM).
\item Referencias a los estilos CSS pues en jQuery también encontramos lo que en CSS denominábamos \emph{selectores}, esto es, cadenas que permiten definir qué es lo que queremos buscar en el DOM, o en otras palabras, qué query queremos aplicar sobre el DOM.
\item El trabajo sobre conjuntos de elementos
\item El tratamiento de eventos
\item La comunicación con el servidor.
\item La integración de AJAX en páginas web.
\end{itemize}


Ejemplo de jQuery:

\begin{verbatim}
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>jQuery demo</title>
</head>
<body>
<a href="http://jquery.com/">jQuery</a>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
<script>
\$(document).ready(function()\{
\$("a").click(function(event)\{
alert("As you can see, the link no longer took you to jquery.com");
event.preventDefault();
\});
\});
</script>
</body>
</html>
\end{verbatim}

Efectos en AJAX:
\begin{verbatim}
\$("a").click(function(event)\{
event.preventDefault();
\$(this).hide("slow");
\});


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>jQuery demo</title>
</head>
<body>
<a href="http://jquery.com/">jQuery</a>
<script 
src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
<script>
\$(document).ready(function()\{
\$("a").click(function(event)\{
event.preventDefault();
\$(this).hide("slow");
\});
\});
</script>
</body>
</html>


\end{verbatim}
Comparándolo con Javascript...
\begin{verbatim}
\$(document).ready(function() \{
\$("a").click(function() \{
alert("Hello world!");
\});
\});
\end{verbatim}
Y en el elemento HTML correspondiente:
\begin{verbatim}
<a href="" onclick="alert('Hello world')">Link</a>
\end{verbatim}

\subsection{LocalStorage y SesionStorage}
Dentro de las múltiples novedades que existen en HTML5, una de ellas es el \textbf{localStorage}. Como su propio nombre indica, se trata de un espacio de almacenamiento local. A muchos les vendrá a la mente las cookies… eso que está tan de moda últimamente en los sitios web por culpa de la conocida como “ley de cookies” (se merece un artículo sólo para ella ;)).

Pues bien, cierto es que con las cookies ya podemos almacenar información en el equipo que accede a la página web… que es exactamente de lo que se trata el \textbf{localStorage}, pero con una serie de salvedades muy importantes.

\subsubsection{localStorage vs Cookies}
La mejor forma de entender por qué es necesario el \textbf{localStorage} es indicando los tres grandes problemas de las cookies:
\begin{enumerate}
\item Espacio limitado: Una cookie sólo puede ocupar 4kb de espacio. Es por eso que las cookies suelen utilizarse sólo para almacenar un hash o un identificador que será utilizado por el servidor para identificar la visita.
\item Cada vez que se realiza una petición al servidor, toda la información que está almacenada en las cookies es enviada y también es recibida nuevamente con la respuesta del servidor. O sea, en los intercambios de información entre el navegador web y el servidor siempre van pegadas las cookies.
\item Las cookies tienen una caducidad.
\end{enumerate}

Y aquí viene \textbf{localStorage} a solucionarlos la vida!

\begin{enumerate}
\item Espacio menos limitado: \textbf{localStorage} puede ocupar entre 5 y 10MB dependiendo del navegador web. Con 5 o 10 megas ya podemos tener algo más de información ;)
\item La información almacenada con \textbf{localStorage} no es enviada al servidor en cada petición.
\item No existe una caducidad para \textbf{localStorage}, la información quedará almacenada hasta que se elimine expresamente. Aunque se cierre el navegador.
\end{enumerate}

Lo sé, una cookie tiene caducidad, pero le puedes poner que caduque dentro de 5 años… vale, sí… pero caduca, con \textbf{localStorage} nos olvidamos de tener que guardar la cookie aumentando el tiempo de caducidad.

Sin embargo, que la información persista en el tiempo, no siempre es una buena idea. A veces lo que interesa es que la información se elimina una vez se cierre el navegador. Para estos casos, en vez de utilizar \textbf{localStorage}, se debe usar \textbf{sessionStorage}.

El \textbf{sessionStorage} es exactamente igual que \textbf{localStorage}, pero con la salvedad de que una vez cerrado el navegador se pierde la información, todo lo demás es lo mismo. Si se quiere trabajar con \textbf{sessionStorage}, sólo hay que coger todo el código de este articulo y donde pone \textbf{localStorage} cambiarlo por \textbf{sessionStorage}.


\section{Componentes Java en el servidor}
Estos componenetes simplifican la programación de servidores en el modelo Web-Java al definir una interfaz con los elementos de comunicación establecidos en el protocolo HTTP y formularios HTML.

Estos componentes pueden ser de tres tipos:
\begin{enumerate}
\item Programas en el servidor: \textbf{Servlets}
\item Páginas dinámicas: \textbf{Java Server Pages, JSP}
\item \textbf{Enterprise Java Beans, EJB}
\end{enumerate}
Todos ellos están definidos en la Java 2 Enterprise Edition, \textbf{J2EE}

\subsection{Servlets}
\begin{defn}[Servlet]
Es una clase en el lenguaje de programación Java, utilizada para ampliar las capacidades de un servidor.
\end{defn}

Aunque los servlets pueden responder a cualquier tipo de solicitudes, éstos son utilizados comúnmente para extender las aplicaciones alojadas por servidores web, de tal manera que pueden ser vistos como applets de Java que se ejecutan en servidores en vez de navegadores web. Este tipo de servlets son la contraparte Java de otras tecnologías de contenido dinámico Web, como PHP y ASP.NET.

En el fondo son similares a los CGI aunque con una sintaxis más sencilla. Además, necesitan un servidir específico, por ejemplo Tomcat.

\begin{defn}[Tomcat]
Apache Tomcat (también llamado Jakarta Tomcat o simplemente Tomcat) funciona como un contenedor de servlets desarrollado bajo el proyecto Jakarta en la Apache Software Foundation. Tomcat implementa las especificaciones de los servlets y de JavaServer Pages (JSP) de Oracle Corporation (aunque creado por Sun Microsystems).
\end{defn}

Los servlets se ejecutan en el servidor y se accede a ellos mediante un URL.

\subsubsection{Portabilidad, felxibilidad y seguridad}
La interconexión del servlet se basa en una API definida en el estándar de Java, independiente de la plataforma. Esto le proporciona gran portabilidad pues el código java es altamente transportable. Además permite aprovechar objetos reutilizables (\textbf{JavaBeans}).

En cuanto a seguridad, los servlets se ejecutan bajo un único proceso (\textbf{servlet engine}), lo que permite acceso protegido y su integración en un entorno de autentificación única (\textbf{single sign on}).

\subsubsection{Ventajas de rendimiento}
Comparten las ventajas de las interfaces híbridas pues tienen un entorno de ejecución propio, se ejecutan y permanecen en memoria, mantienen sesiones entre peticiones HTTP, son multitarea, etc.

\subsubsection{Invocación básica de un Servlet}
\begin{enumerate}
\item El cliente realiza una petición al servidor web, especificando el nombre del servlet como parte de la URL
\item El servidor web pasa la petición a la servlet engine o servlet container, que localiza una instancia de la clase servlet y crea una nueva tarea.
\item La servlet engine ejecuta el método service del servlet
\item La interacción del servlet con el sistema se realiza a través de servicios estándar de la servlet engine, que actúa como contenedor de los objetos y garantiza la independencia de la plataforma.
\end{enumerate}

\subsubsection{Ciclo de vida de los servlets}
\begin{itemize}
\item El método 'init' se ejecuta por la \textbf{servlet engine} al cargarlo
\item El método 'service' se ejecuta en cada petición de los clientes
\item El método 'destroy' se ejecuta por la \textbf{servlet engine} al descargarlo
\end{itemize}

\subsubsection{Http Servlet}
Se trata de un servlet específico para llamadas HTTP.

Define dos nuevos métodos: 'doGet' y 'doPost' que atienden a las peticiones HTTP GET y HTTP POST respectivamente. Ambos métodos se ejecutan desde el método 'service'.

\subsubsection{Crear un servlet}
Para crear un servlet debemos definir una subclase de javax.servlet.http.HttpServlet, implementar alguno de los métodos: 'doGet', 'doPost' o 'service' y dar de alta el servlet en el servidor de servlets.

\subsubsection{Ejecutar un servlet}
\begin{enumerate}
\item El cliente se conecta al servlet como URL
\begin{itemize}
\item Directamente tecleado en el navegador
\item En un enlace HTML ó desde un formulario HTML
\item En un objeto URL de java
\end{itemize}
\item El servlet se carga (en el servidor)
\begin{itemize}
\item Se carga la clase del servlet
\item Se crea una instancia
\end{itemize}
\item El servlet se arranca (en el servidor)
\begin{itemize}
\item Se ejecuta uno de sus métodos
\end{itemize}
\item El servlet termina
\item El cliente lee la salida del servlet, típicamente un string con código HTML para una página web
\end{enumerate}

\subsubsection{Comunicación entre cliente y servlet}
Se realiza por medio de Streams de entrada y salida.

La salida del servlet se emplea para generar páginas web que son enviadas al cliente. La salida del cliente hacia el servlet es menos frecuente; para enviar datos al servlet normalmente se utilizan parámetors.

\textbf{Parámetros HTTP:}

Se envían como parte del URL o con un formulario HTML

\subsubsection{HttpServletRequest}
Se trata de una clase java que representa la petición del cliente. Sus métodos principales son:
\begin{itemize}
\item getParameterNames(): Devuelve una enumeración con los
parámetros recibidos desde la página HTML.
\item getParameterValues(String name): Devuelve los valores de un parámetro multivalorado.
\item getParameter(String name): Devuelve el valor de un
parámetro simple.
\item getReader(): Devuelve un objeto de la clase BufferedReader para leer el cuerpo de la petición HTTP.
\end{itemize}

\subsubsection{HttpServletResponse}
Se trata de una clase java que proporciona el canal de comuncación de retorno con el cliente. Sus métodos principales son:
\begin{itemize}
\item setContentType(String type): Selecciona el tipo MIME de
la respuesta que se devuelve al cliente.
\item sendError(int sc): Devuelve el código de error sc al cliente.
\item sendRedirect(String URL): Redirige el navegador a la URL que se especifica como parámetro.
\item getWriter(): Devuelve un objeto de la clase PrintWriter
para realizar la salida de la página a enviar al cliente, mediante escritura en modo texto.
\item getOutputStream(): Devuelve un objeto de la clase
ServletOutputStream que permite devolver al cliente un
contenido binario.
\end{itemize}

\subsubsection{Gestión de la sesión}
Los servlets gestionan el estado de la sesión a través del objeto HttpSession.

Este objeto representa una conexión cliente-servidor cuya vida se alarga a través de múltiples invocaciones del cliente, incluso a distintos servlets. Se identifican a través de la consulta mediante un identificador de sesión.

El servlet accede a este objeto mediante el método 'getSession'.

Estas sesiones almacenan información específica de la aplicación como parejas clave-objeto a través de los métodos: 'setAttribute' y 'getAttribute'.

Los objetos que se almacenan deben ser serializables y es la \textbf{servlet engine} quien se encarga de establecer el método de identificarlos.

\subsubsection{¿Se debe sincronizar?}
Las especificaciones de Java dicen que no hace falta, puesto que no hay acceso concurrente cuando dos usuarios diferentes acceden a la misma página simultáneamente. Pero con Ajax, es posible que dos llamadas asíncronas del mismo usuario lleguen (casi) simultáneamente.

Por ello debemos tomar precauciones y no sincronizar sobre la instancia del servlet sino sobre la sesión.

\subsubsection{Servlet Context}
Dento de una \textbf{servlet engine} se almacena información asociada al servidor y a los servlets o a determinados grupos de servlets que se ejecutan.

Estos acceden a ell a traves de la clase ServletContext que contiene parámetros para la inicialización así como atributos.

El servlet puede almacenar y recuperar atributos a través de los métodos 'setAttribute' y 'getAttribute'.

\subsubsection{Request Dispatcher}
Se trata de una interfaz que permite a un servlet realizar consultas HTTP redirigiendo la consulta a una nueva URL (forwarding) o ejecutando la consulta y recuperando el control de nuevo tras su ejecución.

Se adqiere a través del contexto mediante el método 'getRequestDispatcher' y tiene dos métodos básicos para realizar los dos tipos de llamadas descritos que reciben como parámetros los mismos objetos que el servlet origen: 'forward' e 'inlcude'.

Ambos métodos permiten ir de un servlet/jsp a otra página web al final del procesamiento, pero son ligeramente distintos:
\begin{itemize}
\item \textbf{Forward}
Se ejecuta internamente sin que el navegador perciba el cambio. Por tanto la URL no cambia y cualquier recarga del navegador cargará la página original.
\item \textbf{Redirect}
Se trata de un proceso en dos pasos donde la aplicación web le indica al navegador que debe acceder a una segunda URL, distinta de la de origen. Una recarga nos mandaría a esa segunda URL.

Es algo más lengo que el 'forward' y los objetos disponibles en el request original no lo están en el segundo.
\end{itemize}

Se debe usar forward sólo si la operación del servlet puede ser repetida sin problemas, sino debe usarse redirect. En el contexto de una base de datos:
\begin{itemize}
\item Usar forward para operaciones SELECT de la base de datos.
– Y normalmente método GET de envío de datos
\item Usar redirect para operaciones INSERT, DELETE, UPDATE.
– Y normalmente método POST de envío de datos.
\end{itemize}

\subsubsection{Ejecución detallada de una petición a un servlet}
\begin{enumerate}
\item El cliente lo solicita mediante una URL con su nombre y clase
\begin{itemize}
\item http://miservidor/servlets/com.ibm.aplicacion.Servlet1
\item Algunos servidores admiten asignación de nombres a cada servlet para independizarlos del nombre de la clase.
\end{itemize}
\item El servidor detecta que se trata de un servlet y lo pasa a la servlet engine.
\item La servlet engine pasa esta información a un servlet especial, denominado invoker.
\item invoker comprueba si el servlet está cargado en memoria
\begin{itemize}
\item Si lo está, crea una nueva tarea (hilo) sobre la misma instancia.
\item Si no lo está, busca el objeto en el CLASSPATH, crea una nueva instancia, ejecuta su método init y ejecuta la petición.
\end{itemize}
\end{enumerate}

\subsection{JavaServer Pages (JSP)}
\begin{defn}[JSP]
Es una tecnología que ayuda a los desarrolladores de software a crear páginas web dinámicas basadas en HTML, XML, entre otros tipos de documentos. JSP es similar a PHP, pero usa el lenguaje de programación Java.
\end{defn}

Permite mezclar código HTMl y código Java, necesita un servidor web que lo soporte y se accede igual que a una página html desde un navegador. Se ejecutan en una \textbf{servlet engine (jsp engine)}

Las JSP son convertidas en un servlet dinámicamente la primera vez que se ejecutan y se crea un objeto que implemente la interfaz HttpJspPage.

Un archivo JSP contiene código HTML nativo, elementos de JSP (directivas o acciones estándar, elementos del lenguaje, etc).

\subsubsection{Objetos implícitos}
Hay una serie de objetos que siempre se encuentra definidos en una JSP sin necesidad de que los defina el usuarios. Los principales son:
\begin{itemize}
\item page: Representa la página jsp que se está ejecutando.
\item request: Consulta recibida del usuario (tipo HttpServletRequest).
\item response: Objeto para generación de resultado (tipo HttpServletResponse).
\item session: Sesión de trabajo del cliente (tipo HttpSession)
\item application: Contexto de los servlets (tipo ServletContext)
\item out: Permite la escritura en la página de salida (tipo JspWriter)
\item exception: En páginas de error, contiene la condición de error por la que se han ejecutado.
\end{itemize}

\subsubsection{Directivas y acciones}
\begin{itemize}
\item Directivas: Mensajes para la \textbf{jsp engine}
\begin{verbatim}
– <%@ page {atributo="valor"}* %>
Define propiedades generales de la página: lenguaje, Classpath,
herencia, imports...
– <%@ include file="nombre_archivo" %>
Orden de incluir un archivo en la página actual, en tiempo de
compilación.
– <%@ taglib uri="URI_archivo_etiquetas" %>
Referencia a un archivo con declaración de etiquetas de usuario.
\end{verbatim}
\item Aciones: Comandos a realizar en tiempo de ejecución
\begin{verbatim}
– <jsp:include page="URLrelativa" />
– <jsp:forward page="URLrelativa" />
  /*Los dos anteriores realizan una llamada al RequestDispatcher */
– <jsp:useBean id="nombre" scope="page|request|session|application"
class="nombreCompletoClase" />
Define para su uso en la página un javaBean con el nombre
"nombre".
– <jsp:setProperty name="nombre" property="propName"
value="valor"/>
Activa una propiedad del JavaBean "nombre".
– <jsp:getProperty name="nombre" property="propName" />
Recupera una propiedad del JavaBean "nombre" y la almacena en la
página.
\end{verbatim}
\end{itemize}

\subsubsection{Elementos del lenguaje}
\begin{verbatim}
Declaraciones de variables y métodos
– <%! declaracion %>
– Se pueden declarar aquí los métodos especiales
• jspInit(): Se ejecuta al iniciar la página JSP.
• jspDestroy(): Se ejecuta al destruir la página JSP.
Scriptlets: Contiene cualquier fragmento de código válido en lenguaje Java.
– <% fragmento_de_código %>
– El código introducido se copia al cuerpo del método del servlet compilado
Expresiones: Cualquier expresión Java válida
– <%= expresión %>
– En tiempo de ejecución:
• Se evalúa la expresión.
• El resultado se convierte a String.
• Se presenta en la página resultado.
\end{verbatim}

\subsubsection{Ejecución detallada de una petición de una JSP}
\begin{enumerate}
\item El cliente envía una petición.
\item El servidor detecta que la petición se resuelve mediante JSP.
\begin{itemize}
\item Pasa la petición a la servlet engine correspondiente.
\end{itemize}
\item La servlet engine comprueba si el archivo JSP está compilado.
\begin{itemize}
\item Si no lo está, lo compila mediante un servlet de compilación de páginas (PageCompileServlet, JspServlet)
\end{itemize}
\item La servlet engine pasa la petición al servlet invoker, que actúa como con cualquier otro servlet:
\begin{itemize}
\item Comprueba si está instanciado, y si no lo está, lo instancia y ejecuta su método init.
\item La servlet engine ejecuta el método correspondiente del servlet en una nueva tarea (hilo) para atender al servicio.
\end{itemize}

\end{enumerate}
\normalsize
\printindex
\end{document}
