\documentclass{apuntes}

\title{Sistemas Informaticos}
\author{Elena Gutiérrez y Pedro Valero}
\date{14/15 C1}

% Paquetes adicionales

% --------------------

\begin{document}
\pagestyle{plain}
\maketitle

\tableofcontents
\newpage
\setcounter{chapter}{1}
\chapter{Sistemas distribuidos basados en la WWW}

Las partes 1 y 2 de este tema se consideran demasiado triviales y se deja como ejercicio para el lector el leerse los apuntes y haber realizado las prácticas. (Son las que hablan del XML, XSL y esas cosillas).

\setcounter{section}{2}
\section{Web interactiva (Aplicaciones Web)}
El modelo de Web hipertexto no permite más iteracción del usuario que seleccionar la URL y comienza a hacerse necesario establecer comunicación entre programas del servidor con datos que proporciona el usuario, ya sea por medio de formularios (forms) o mediante la ejecución de programas en el propio servidor (Common Gateway Interface, CGI)

\subsection{CGIs}
\begin{defn}[CGI]
El CGI define el método para que un servidor WWW puede ejecutar programas externos y recoger información de ellos. Estos programas reciben el nombre de CGIs
\end{defn}

Esta tecnología de la World Wide Web (es una extensión del protocolo HTTP) permite que un cliente (el navegador) pueda solicitar los datos de un programa ejecutado en un servidor web. Fueron de los primeras métodos para crear contenido dinámico para las páginas web. El servidor web pasa las solicitudes del cliente a un programa externo (éste suele estar escrito en lenguaje script), y la salida de este programa es enviada al cliente en lugar del archivo estático tradicional.

\textbf{Forma esquemática de actualización de un CGI}
\begin{enumerate}
\item El servidor recibe una petición por parte del cliente que activa un URL que contiene el CGI
\item El servidor prepara el entorno para ejecutar la aplicación. La información necesaria procede en su mayoría del cliente (el formulario de entrada). EL servidor también envía a la aplicación, información de origen, URL que el usuario solicita, protocolo utilizado, etc. El paso de información a través del CGI se realiza mediante variables de entorno, línea de comandos y entrada y salida estándar (stdin y stdout). Los nombres de las variables de entorno pueden ser específicos del sistema. Hay diferentes tipos de variables de entorno:
\begin{itemize}
\item Variables de entorno independientes de la petición.
\item Variables de entorno dependientes de la consulta en cuestión
\item Variables de entorno relacionadas con la seguridad de acceso.
\item Variables de entorno sobre info adicionan de la consulta
\item Variables de entorno de la cabecera HTTP.
\end{itemize}
\item El  servidor ejecuta la aplicación y captura la salida estándar.
\item La aplicación realiza su función y como resultado va generando un objeto MIME que la aplicación escribe en su salida estándar.
\item El servidor envía la información producida junto con la información propia del cliente. Es responsabilidad de la aplicación informar del objeto MIME que se genera.
\end{enumerate}

\subsection{Formularios}
\subsubsection{Protocolos}
HTTP + páginas HTML

\subsubsection{Funcionamiento básico}
\begin{enumerate}
\item El cliente solicita la página al servidor web.
\item El servidor envía una página que contiene el formulario.
\item El cliente lo rellena y lo devuelve al servidor.
\item El servidor, por la URL que el cliente solicita, ejecuta el programa al que pasa los datos recibidos del cliente.
\item El programa genera una página con los resultados de su ejecución y la devuelve al cliente a través del servidor web.
\end{enumerate}

\newpage
\subsubsection{Estructura y sintaxis}
La estructura de un formulario es la que sigue:
\begin{verbatim}
<FORM ACTION=url METHOD=método de envío>
  <INPUT> | <TEXTAREA> | <SELECT> | <BUTTON>
  otros elementos HTML
</FORM>
\end{verbatim}

Veamos con un poco más de detalle cuál es la función de cada campo del formulario:
\begin{itemize}
\item \textbf{Action:} Aquí se especifica la URL que se debe solicitar al enviar el formulario.
\item \textbf{Method:} Metodo de envio de los datos asociados al formulario. Pueden viajar asociados a la URL que se pide o en el cuerpo del mensaje HTTP.
\item Si \textbf{METHOD = GET} el mensaje HHTP es:
\begin{verbatim}
GET /logon?usuario=Superman&clave=loislane&nuevo=si
HTTP/1.1
(otras cabeceras HTTP)
(línea en blanco).
\end{verbatim}
\item Si \textbf{METHOD = POST}, el mensaje habría sido:
\begin{verbatim}
POST /logon HTTP/1.1
CONTENT-TYPE: application/x-www-form-urlencoded
CONTENT-LENGT: xxx
(otras cabeceras HTTP)
(línea en blanco)
usuario=Superman&clave=loislane&nuevo=s
\end{verbatim}
\end{itemize}

\subsubsection{Ventajas e inconvenientes}
\textbf{Ventajas:}
\begin{itemize}
\item Sencillez de programación.
\item Permite el uso de cualquier lenguaje de programación (normalmente PERL e interpretados)
\item El programa CGI no puede afectar al funcionamiento del servidor por ejecutarse como un proceso independiente.
\item Estándar, de modo que generaliza la portabilidad entre servidores de distintos fabricantes.
\end{itemize}
\textbf{Inconvenientes:}
\begin{itemize}
\item Lento. Cada ejecucion requiere iniciar un proceso y termianrlo: reservas de memoria, apertura de ficheros, conexiones a bases de datos...
\item Funciona por sesiones de modo que el programa CGI termina con cada llamada y no mantiene el estado de la comunicación entre peticiones.
\end{itemize}

\section{Web Application Programming Interfaces (Web APIs)}
\subsection{Introducción}
\begin{defn}[API]
Una \textbf{API} es una interfaz de programación de aplicaciones (del inglés API: Application Programming Interface). Es un conjunto de rutinas que provee acceso a funciones de un determinado software.
\end{defn}

Son publicadas por los constructores de software para permitir acceso a características de bajo nivel o propietarias, detallando sólamente la forma en que cada rutina debe ser llevada a cabo y la funcionalidad que brinda, sin otorgar información acerca de cómo se lleva a cabo la tarea. Son utilizadas por los programadores para construir sus aplicaciones sin necesidad de volver a programar funciones ya hechas por otros, reutilizando código que se sabe que está probado y que funciona correctamente.

En la web, las API's son publicadas por sitios para brindar la posibilidad de realizar alguna acción o acceder a alguna característica o contenido que el sitio provee. Algunas de las más conocidas son las API's de: Google Maps, Amazon, Flickr, Google Search, Futmondo, Xnxx, ...

Surgen para mitigar el bajo rendimiento de la interfaz CGI. En este caso, los nuevos programas se enlazan junto con el servidor en una librería dinámica, El servidor llama a las funciones de la librería como tareas dentro del proceso servidor. El proceso, en este caso, no finaliza: se mantienen ficheros abiertos, conexiones a base de datos y demás entre las llamadas. Se proporciona una API de acceso a datos y estado del servidor.

Presenta inconvenientes. Un fallo en una rutina hace que pueda caer el servidor completo. Se hace uso de lenguajes como C, C++, que en este aspecto están limitados. Dificil de programar, pues es necesario conocer el funcionamiento del servidor para aprovecharlas al máximo.

Algunos ejemplos: Netscape (NSAPI), Microsoft (ISAPI), IBM (ICAPI, GWAPI)...

\subsection{Interfaces Híbridas:}
Tratan de evitar los inconvenientes que veíamos de las CGIs y las Web APIs.
Los programas se realizan independientemente del servidor Web y en cualquier lenguaje.
El servidor durante la inicialización puede arrancar los programas en procesos diferentes.
Los programas se inicializan antes de recibir la petición, y quedan a la espera de recibirlas.

Ya no hay comunicación por medio de variables de entorno, Se utilizarán mecanismos de comunicación entre procesos más rápidos como acceso remoto mediante mecanismos de comunicación o bien empleando los mismos elementos que empleaban los CGIs para facilitar la migración de programas CGI a nuevas interfaces.
Es posible mantener el estado de la aplicación entre peticiones sucesivas y una vez que la petición es atendida, el programa vuelve a esperar otra petición.

\newpage
Ejemplos:
\begin{itemize}
\item FastCGI, de Open Market, Inc. Comunicación Servidor - Programas por Sockets.
\item Netscape Web Application Interface (WAI). Comunicación mediante CORBA.
\end{itemize}

\subsection{Páginas dinámicas:}
Se trata de extensiones del lenguaje HTML para permitir mayor capacidad de proceso. En el cliente (client side scripts) se lleva a cabo la inclusión de código que el cliente interpretará para variar dinámicamente la presentación de la página, proporcionando así “inteligencia” al navegador. En el servidor (server side scripts) se realiza una inclusión de código en el fichero que contiene la descripción de la página. De este modo, el servidor lo interpretará para variar la generación de la página antes de su envío al cliente.

Se trata de una alternativa a la programación CGI.

\section{El lenguaje PHP}
\subsection{Introducción}
Se trata de un lenguaje de programación interpretado para el servidor. Presenta una sintaxis parecida a C y C++ y permite acceso a formularios, archivos, bases de datos, etc.

Para el acceso a información propia del servidor se utiliza un  array indexado con el nombre del parámetro al que se desea acceder. El nombre del array es \$\_SERVER[indice] donde índice puede ser: QUERY\_STRING, REMOTE\_HOST,....

Existen otros arrays indexados como \$\_REQUEST, para el acceso a variables asociadas a la petición recibida (campos de un formulario)
También existe \$\_SESSION que permite acceder a información de la sesión del usuario. El array \$\_REQUEST, tras una petición del cliente, incluye los contenidos de tres tipos de variables:
\begin{itemize}
\item \$\_GET Parámetros recibidos en un comando HTTP GET
\item \$\_POST Parámetros recibidos en un comando HTTP POST
\item \$\_COOKIES Lista de cookies recibidas con la petición.
\end{itemize}

Otras variables ya definidas son:
\begin{itemize}
\item\$\_FILES
\item\$\_ENV
\item\$\_GLOBALS
\end{itemize}

PHP es un lenguaje de script del lado del servidor (similar a otros lenguajes como ASP, JSP o Coldfusion). Sus siglas significan PHP Hypertext Processor. En este caso, el script está incrustado en el código HTML y el servidor lo interpreta y ejecuta antes de servir la página al cliente. El cliente no ve el código PHP sino sus resultados. Es software abierto y gratuito, Para permitir el acceso a bases de datos, tenemos PHP + [PostgreSQL, MySQL], que es multiplataforma.

\subsection{Características del lenguaje}
\begin{verbatim}
$variable : Permite declarar variables. (Recuerda: es case sensitive). Ha de
 comenzar por letra o _ y después letras, números o _ (Recordemos el examen
  de AUTLEN). En  cuanto a su ámbito, son globales al fichero, excepto si
   aparecen en una función , que son locales.
echo $variable1.””.$variable2: Permite concatenar cadenas e imprimirlas.
echo strpos("Hello world!","world") : Devuelve la posición en la que
 comienza la cadena que es el segundo argumento.
echo strlen("Hello world!");: Devuelve la longitud de la cadena (no cuenta /0)
\end{verbatim}

Veamos un ejemplo de declaración de una función:
\begin{verbatim}
function functionName()
{
  code to be executed;
}
\end{verbatim}

Ejemplo de declaración y uso de arrays:
\begin{verbatim}
$cars=array("Saab","Volvo","BMW","Toyota");
<?php
  $cars[0]="Saab";
  $cars[1]="Volvo";
  $cars[2]="BMW";
  $cars[3]="Toyota";
  echo $cars[0] . " and " . $cars[1] . " are Swedish cars.";
?>
\end{verbatim}
Resultado: Saab and Volvo are Swedish cars.

Ejemplo de declaración y uso de arrays \textbf{ASOCIATIVOS}
\begin{verbatim}
$ages = array("Peter"=>32, ”Mike"=>30, "Joe"=>34);
<?php
  $ages['Peter'] = "32";
  $ages['Mike'] = "30";
  $ages['Joe'] = "34";
  echo "Peter is " . $ages['Peter'] . " years old.";
?>
\end{verbatim}
Resultado: Peter is 32 years old.

\subsection{Tipos de datos en PHP}
PHP soporta 8 tipos de datos primitivos:
\begin{itemize}
\item Escalares: boolean, integer, double y string.
\item Compuestos: Array y object
\item Especiales: resource y NULL.
\end{itemize}
El tipo de dato no se suele especificar, sino que es en tiempo de ejecución cuando se determina en función del contexto. En este aspecto, algunas funciones interesantes son:
\begin{itemize}
\item gettype() que devuelve el tipo de una variable.
\item istype() por ejemplo: is\_array(), is\_float(), is\_null(), is\_numeric(), is\_scalar()..
\item var\_dump() muestra tipo y valor de una variable (interesa cuando usamos arrays).
\end{itemize}

\subsubsection{String}
Las cadenas pueden parecer entre comillas simples o dobles:
\begin{verbatim}
- Simples: admiten caracteres de escape como \’ (comilla simple) y \\ (barra).
Las variables no se expanden (es decir: ‘a vale $a’ muestra “a vale $a”)
- Dobles: admiten más caracteres de escape como \n, \r, \t, \\, \$, \”. En
 este caso, las variables sí se expanden: “a vale 9”
\end{verbatim}
Para acceder a un carácter de la cadena usamos: \$letra = \$cadena\{8\};


\subsubsection{Constantes}
Se definen así:
\begin{verbatim}
define (“CONSTANTE”, “hola); es decir define (“NOMBRE“, “valor”).
\end{verbatim}
No llevan \$ delante y solo se pueden definir constantes de tipo escalar: boolean, integer, string y double.

\newpage
\subsection{Funciones: Paso por referencia}
Si no indicamos nada los parámetros se pasan por valor.

Ejemplo:
\begin{verbatim}
function incrementa (&$a)
{
  $a = $a + 1;
}
$a=1;
incrementa ($a);
print $a; // Muestra un 2
\end{verbatim}

Ejemplo de función y array:

\begin{verbatim}
<HTML>
<HEAD>
  <TITLE>Fecha</TITLE>
  <?PHP
    // Función que obtiene el nombre de un mes
    function nombreMes ($mes)
    {
      $meses = array ("enero", "febrero", "marzo", "abril", "mayo",
      "junio", "julio", "agosto", "septiembre",
      "octubre", "noviembre", "diciembre");
      $i=0;
      $enc=false;
      while ($i<12 and !$enc)
      {
        if ($i == $mes-1)
        $enc = true;
        else
        $i++;
      }
      return ($meses[$i]);
    }
  ?>
</HEAD>
<BODY>
  <H1>Tablas y funciones</H1>
  <?PHP
    $dia = date ("j");
    $mes = date ("n");
    $anyo = date ("Y");
    print ("Hoy es " . $dia . " de " . nombreMes($mes) .
    " de " . $anyo . "<BR>\n");
  ?>
</BODY>
</HTML>
\end{verbatim}

\subsection{HTML + PHP: Formularios}
Si declaramos en el html un elemento form con el campo method = “GET” entonces en el código php (incluido en otro fichero a parte) debemos acceder a los campos input mediante: GET[“atributo”] donde “atributo” es el valor del campo name del elemento input.

Particularidades:
\begin{enumerate}
\item Si “atributo” era type = “text” : \$atributo = GET[“atributo”] guardará el texto que introdujimos.

\item Si “atributo” era type = “radio” : Haremos \$atributo = GET[“atributo”] que guardara el campo value de la opción que hayamos pinchado.

\item Si “atributo” era type = “checkbutton”  y por tanto name= valores[]: Haremos \$valores = GET[“valores”] que guardará en forma de array los valores que han sido marcados (y por tanto la longitud del array será igual al número de “tics” que hayan sido marcados). Podemos imprimirlos así:
\begin{verbatim}
$valores= $_GET['valores'];
$n = count ($valores);
for ($i=0; $i<$n; $i++)
  print ("$valores[$i]<BR>\n");
\end{verbatim}
y solo se imprimirán aquellos campos “value “ de los que fueron marcados.

\item Si “atributo” era de type=“button” guardaremos en \$atributo=\$\_GET[“atributo”] true or false (no se si eso exactamente pero el equivalente a esto en php). De este modo, tiene sentido poner:
\begin{verbatim}
if ($actualizar)
  print("Se han actualizado los datos");
\end{verbatim}
%\begin{obs} Este tipo no funciona igual que “submit”. En este último caso, podemos acceder al .php al que asociamos el formulario, sin embargo escribiendo button, aun poniendo la url en el campo action de form, no funciona?
%\end{obs}

\item Podemos usar de manera análoga: password, <SELECT AREA>, <SELECT MULTIPLE> <TEXTAREA>

\item Importante:
Una de las ventajas de PHP es que se puede procesar y mostrar el formulario desde un mismo .php. La estructura debe ser la siguiente:
\begin{verbatim}
si se ha enviado el formulario:
  si hay errores:
    Mostrar formulario con errores
  si no:
    Procesar formulario
si no:
  Mostrar formulario
\end{verbatim}
La clave para que esto funcione es en el formulario indicar que el campo action es el mismo php que en el que nos encontramos. Además para comprobar que se ha pulsado o no el botón de submit, debemos usar la condición:
if (isset(\$aceptar)) o bien if (\$aceptar==”Aceptar”).
Para ver un ejemplo, mirar el ejercicio que se pidió subir a moodle.
\end{enumerate}

\subsection{Cookies}
Se trata de un pequeño fichero que el servidor introduce en el pc del cliente (con el permiso de su navegador). Cada vez que el navegador solicite una nueva página  a ese servidor, le enviará también la cookie.

\subsubsection{Sintaxis}
Se coloca antes de la etiqueta <html>
\begin{verbatim}
<?php
setcookie("user", ”Bob Sponge", time() + 60 * 60);
?>
<html>
...
\end{verbatim}

La variable \$\_COOKIE es un array que guarda (name,value, expire, path, domain) que son los campos que se introducen en la función setcookie. Esta información es la que viaja en un fichero cada vez que se produce una comunicación entre el servidor y el cliente.

Para imprimirlos:

\begin{verbatim}
echo $_COOKIE[“user”;
\end{verbatim}
Para ver todas:
\begin{verbatim}
print_r($_COOKIE);
\end{verbatim}
Para verificar que una en concreto existe:
\begin{verbatim}
if(isset($_COOKIE[“user”]))....
\end{verbatim}

\subsection{Sesiones}
Por último, en PHP encontramos una variable que es \$\_SESSION que guarda valores relativos a la sesión que se tiene abierta. Es útil cuando el servidor quiere llevar el rastro del usuario durante un tiempo finito, por ejemplo, cuando el cliente visita varios lugares de un supermercado añadiendo productos a un carrito de la compra.

\subsubsection{Sintaxis}
Algunas de las funciones más importantes son:
\begin{itemize}
\item \textbf{session\_start()}; Comienza la sesión
\item \textbf{\$\_SESSION[‘name’] = “Elena”}; Establece el nombre o identificador  de la sesión
\item \textbf{unset(\$\_SESSION[‘name])}; Borra el identificador del usuario (elimina una única variable del array \$\_SESSION). Otro ejemplo:
\item \textbf{unset(\$\_SESSION['session\_var'])};
\item \textbf{session\_unset()}; Borra los contenidos de la sesión pero mantiene el id y el nombre de la sesión.
\item \textbf{session\_destroy()}; Elimina la sesión (no sólo los datos que fueron guardados en la misma)
\end{itemize}

\section{Ejecución de código en el cliente: javascript, ajax, jQuery}

\subsection{Javascript}
\subsubsection{Introducción}
Enriqueze las páginas HTML incorporando características dinámicas e iteractivas. Se ejecuta siempre en el cliente, sin necesidad de acudir al servidor en busca de información. Se emplea para manipular contenidos de forma dinámica, validación de formularios, etc.

Es un lenguaje interpretado y orientado a objetos. Presenta una sintáxis muy similar a Java (y a C).

Fue desarrollado por Netscape en colaboración con Sun. Tiene dos usos fundamentales:
\begin{itemize}
\item \textbf{DHTML}=Dynamic HTML
Consiste en la combinación de HTML+Javascript+CSS y no tiene nada que ver con la generación dinámica de páginas web en el servidor.
\item \textbf{AJAX}=Asynchronous JavaScript And XML.
Consiste en la combinación de JavaScript y una comunicación cliente-servidor asíncrona. Permite tener aplicaciones interactivas.

\item \textbf{JQuery}
Es una biblioteca de JavaScript, creada inicialmente por John Resig, que permite simplificar la manera de interactuar con los documentos HTML, manipular el árbol DOM, manejar eventos, desarrollar animaciones y agregar interacción con la técnica AJAX a páginas web
\end{itemize}

\subsubsection{Características}
Está enfocado al manejo de elementos de documentos HTML y el navegador web, minimizando el trasiego de datos entre el cliente y el servidor.

Permite realizar tareas sencillas que no requieren mucha más información que la proporcionada por el usuario a través del propio documento HTML sobre el que se ejecuta. No se compila sino que se interpreta y aparece insertado en el código HTML.

Por comodidad, el código suele escribirse en la cabecera del docuemto HTML o en un fichero aparte, que será enviado junto con el HTML ante la solicitud de un cliente.

Es case-sensitive, orientado a objetos y finaliza las sentencias con ';'

\subsubsection{Variables}
Son 'no tipadas', es decir, no se declara el tipo de dato y, además, puede cambiar a lo largo de la ejecución de un programa.

\subsubsection{Objetos}
En este aspecto es muy similar a Java. Cada objeto consta de unas propiedades y una serie de métodos/eventos. Los métodos son llamados por el propio programador al escribir el programa mientras que los eventos son acciones que ocurren en la interfaz gráfica sobre un objeto de la misma.

Los eventos se emplean para responder a clicks del raton, pulsaciones de teclas, etc.

En JavaScript existe un objeto llamado document, que engloba todo el fichero html. De él cuelgan a modo de árbol los diferentes elementos del documento a los que podemos acceder de forma directa mediante las funciones: 'getElementById' o 'getElementByTagName', o descendiendo por el árbol: 'document.forms[0].elements[3]

\subsection{AJAX}
\begin{defn}[AJAX]
Acrónimo de Asynchronous JavaScript And XML (JavaScript asíncrono y XML), es una técnica de desarrollo web para crear aplicaciones interactivas o RIA (Rich Internet Applications).
\end{defn}

Estas aplicaciones se ejecutan en el cliente, es decir, en el navegador de los usuarios mientras se mantiene la comunicación asíncrona con el servidor en segundo plano. De esta forma es posible realizar cambios sobre las páginas sin necesidad de recargarlas, mejorando la interactividad, velocidad y usabilidad en las aplicaciones.

Ajax es una tecnología asíncrona, en el sentido de que los datos adicionales se solicitan al servidor y se cargan en segundo plano sin interferir con la visualización ni el comportamiento de la página. JavaScript es el lenguaje interpretado (scripting language) en el que normalmente se efectúan las funciones de llamada de Ajax mientras que el acceso a los datos se realiza mediante XMLHttpRequest, objeto disponible en los navegadores actuales. En cualquier caso, no es necesario que el contenido asíncrono esté formateado en XML.

Ajax es una técnica válida para múltiples plataformas y utilizable en muchos sistemas operativos y navegadores dado que está basado en estándares abiertos como JavaScript y Document Object Model (DOM).

\subsubsection{Ejemplo de funcionamiento}
\small
\begin{verbatim}
<html>
  <head>
    <script type="text/javascript">
      function loadXMLDoc() {
        var xmlhttp;
         if (window.XMLHttpRequest) {
          // code for IE7+, Firefox, Chrome, Opera, Safari
          xmlhttp=new XMLHttpRequest();
         }
        else {
          // code for IE6, IE5
          xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
      }
\end{verbatim}
\normalsize
Con esto hemos creado el objeto XMLHttpRequest mencionado anteriormente.
\small
\begin{verbatim}
      xmlhttp.onreadystatechange=function() {
        if (xmlhttp.readyState==4 && xmlhttp.status==200){
          document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
        }
\end{verbatim}
\normalsize
Se recoge la respuesta
\small
\begin{verbatim}
      }
      xmlhttp.open("GET","ajax_info.txt",true);
      xmlhttp.send();
\end{verbatim}
\normalsize
Enviamos la petición al servidor
\small
\begin{verbatim}
      }
    </script>
  </head>
  <body>
    <div id="myDiv"><h2>Let AJAX change this text</h2></div>
    <button type="button" onclick="loadXMLDoc()">Change Content</button>
\end{verbatim}
\normalsize
Al pulsar el botón se ejecuta la función 'loadXMLDoc()'
\small
\begin{verbatim}
  </body>
</html>
\end{verbatim}

\subsubsection{Objeto XMLHttpRequest}
\begin{defn}[Objeto XMLHttpRequest]
(XHR), también referida como XMLHTTP (Extensible Markup Language / Hypertext Transfer Protocol), es una interfaz empleada para realizar peticiones HTTP y HTTPS a servidores Web. Para los datos transferidos se usa cualquier codificación basada en texto, incluyendo: texto plano, XML, JSON, HTML y codificaciones particulares específicas. La interfaz se implementa como una clase de la que una aplicación cliente puede generar tantas instancias como necesite para manejar el diálogo con el servidor.
\end{defn}
Es soportado por todos los navegadores modernos salvo IE5 e IE6 que emplean ActiveXObjetc. Esto cause que necesitemos poner un if en el ejemplo anterior con el fin de funcionar sobre cualquier navegador.

Se emplea para intercambiar datos con el servidor detrás de la escena, mientras la página web sigue funcionando normalmente. Esto es lo que permite actualizar parcialmente una página web.

En el ejemplo se observan dos métodos empleados sobre el objeto (además del creador):
\begin{itemize}
\item \textbf{xmlhttp.open}
Especifica el tipo de petición (GET o POST), la URL y si la petición debe atenderse de forma asíncrona o no.
\item \textbf{xmlhttp.send}
Envía la petición al servidor. Sólo recibe argumentos en caso de que la petición sea de tipo POST
\end{itemize}

Tras realizar la petición es necesario \textbf{recoger la respuesta}. La forma de hacerlo varía según la forma en que se intercambie la información.

Si es asíncrono se emplea la función: 'xmlhttp.onreadystatechange=function()', que implica que en cuanto se reciva la información solicitada se invoque a la función indicada.

Si es síncrono se coloca el código justo después del 'send', que quedará esperando la respuesta.

Si la codificación está basada en XML nos apoyamos en la propiedad 'responseXML', que contiene el contenido de la respuesta del servidor en formato XML.

Sin embargo, si la codificación es por medio de texto plano, nos debemos apoyar en la propiedad 'responseText' que contiene la respuesta del servidor en forma de cadena de texto.

\subsection{Biblioteca AJAX: jQuery}
\begin{defn}[jQuery]
Es una biblioteca de JavaScript, creada inicialmente por John Resig, que permite simplificar la manera de interactuar con los documentos HTML, manipular el árbol DOM, manejar eventos, desarrollar animaciones y agregar interacción con la técnica AJAX a páginas web.
\end{defn}

\subsection{LocalStorage y SesionStorage}
Dentro de las múltiples novedades que existen en HTML5, una de ellas es el \textbf{localStorage}. Como su propio nombre indica, se trata de un espacio de almacenamiento local. A muchos les vendrá a la mente las cookies… eso que está tan de moda últimamente en los sitios web por culpa de la conocida como “ley de cookies” (se merece un artículo sólo para ella ;)).

Pues bien, cierto es que con las cookies ya podemos almacenar información en el equipo que accede a la página web… que es exactamente de lo que se trata el \textbf{localStorage}, pero con una serie de salvedades muy importantes.

\subsubsection{localStorage vs Cookies}
La mejor forma de entender por qué es necesario el \textbf{localStorage} es indicando los tres grandes problemas de las cookies:
\begin{enumerate}
\item Espacio limitado: Una cookie sólo puede ocupar 4kb de espacio. Es por eso que las cookies suelen utilizarse sólo para almacenar un hash o un identificador que será utilizado por el servidor para identificar la visita.
\item Cada vez que se realiza una petición al servidor, toda la información que está almacenada en las cookies es enviada y también es recibida nuevamente con la respuesta del servidor. O sea, en los intercambios de información entre el navegador web y el servidor siempre van pegadas las cookies.
\item Las cookies tienen una caducidad.
\end{enumerate}

Y aquí viene \textbf{localStorage} a solucionarlos la vida!

\begin{enumerate}
\item Espacio menos limitado: \textbf{localStorage} puede ocupar entre 5 y 10MB dependiendo del navegador web. Con 5 o 10 megas ya podemos tener algo más de información ;)
\item La información almacenada con \textbf{localStorage} no es enviada al servidor en cada petición.
\item No existe una caducidad para \textbf{localStorage}, la información quedará almacenada hasta que se elimine expresamente. Aunque se cierre el navegador.
\end{enumerate}

Lo sé, una cookie tiene caducidad, pero le puedes poner que caduque dentro de 5 años… vale, sí… pero caduca, con \textbf{localStorage} nos olvidamos de tener que guardar la cookie aumentando el tiempo de caducidad.

Sin embargo, que la información persista en el tiempo, no siempre es una buena idea. A veces lo que interesa es que la información se elimina una vez se cierre el navegador. Para estos casos, en vez de utilizar \textbf{localStorage}, se debe usar \textbf{sessionStorage}.

El \textbf{sessionStorage} es exactamente igual que \textbf{localStorage}, pero con la salvedad de que una vez cerrado el navegador se pierde la información, todo lo demás es lo mismo. Si se quiere trabajar con \textbf{sessionStorage}, sólo hay que coger todo el código de este articulo y donde pone \textbf{localStorage} cambiarlo por \textbf{sessionStorage}.

\section{Componentes Java en el servidor}
Estos componenetes simplifican la programación de servidores en el modelo Web-Java al definir una interfaz con los elementos de comunicación establecidos en el protocolo HTTP y formularios HTML.

Estos componentes pueden ser de tres tipos:
\begin{enumerate}
\item Programas en el servidor: \textbf{Servlets}
\item Páginas dinámicas: \textbf{Java Server Pages, JSP}
\item \textbf{Enterprise Java Beans, EJB}
\end{enumerate}
Todos ellos están definidos en la Java 2 Enterprise Edition, \textbf{J2EE}

\subsection{Servlets}
\begin{defn}[Servlet]
Es una clase en el lenguaje de programación Java, utilizada para ampliar las capacidades de un servidor.
\end{defn}

Aunque los servlets pueden responder a cualquier tipo de solicitudes, éstos son utilizados comúnmente para extender las aplicaciones alojadas por servidores web, de tal manera que pueden ser vistos como applets de Java que se ejecutan en servidores en vez de navegadores web. Este tipo de servlets son la contraparte Java de otras tecnologías de contenido dinámico Web, como PHP y ASP.NET.

En el fondo son similares a los CGI aunque con una sintaxis más sencilla. Además, necesitan un servidir específico, por ejemplo Tomcat.

\begin{defn}[Tomcat]
Apache Tomcat (también llamado Jakarta Tomcat o simplemente Tomcat) funciona como un contenedor de servlets desarrollado bajo el proyecto Jakarta en la Apache Software Foundation. Tomcat implementa las especificaciones de los servlets y de JavaServer Pages (JSP) de Oracle Corporation (aunque creado por Sun Microsystems).
\end{defn}

Los servlets se ejecutan en el servidor y se accede a ellos mediante un URL.

\subsubsection{Portabilidad, felxibilidad y seguridad}
La interconexión del servlet se basa en una API definida en el estándar de Java, independiente de la plataforma. Esto le proporciona gran portabilidad pues el código java es altamente transportable. Además permite aprovechar objetos reutilizables (\textbf{JavaBeans}).

En cuanto a seguridad, los servlets se ejecutan bajo un único proceso (\textbf{servlet engine}), lo que permite acceso protegido y su integración en un entorno de autentificación única (\textbf{single sign on}).

\subsubsection{Ventajas de rendimiento}
Comparten las ventajas de las interfaces híbridas pues tienen un entorno de ejecución propio, se ejecutan y permanecen en memoria, mantienen sesiones entre peticiones HTTP, son multitarea, etc.

\subsubsection{Invocación básica de un Servlet}
\begin{enumerate}
\item El cliente realiza una petición al servidor web, especificando el nombre del servlet como parte de la URL
\item El servidor web pasa la petición a la servlet engine o servlet container, que localiza una instancia de la clase servlet y crea una nueva tarea.
\item La servlet engine ejecuta el método service del servlet
\item La interacción del servlet con el sistema se realiza a través de servicios estándar de la servlet engine, que actúa como contenedor de los objetos y garantiza la independencia de la plataforma.
\end{enumerate}

\subsubsection{Ciclo de vida de los servlets}
\begin{itemize}
\item El método 'init' se ejecuta por la \textbf{servlet engine} al cargarlo
\item El método 'service' se ejecuta en cada petición de los clientes
\item El método 'destroy' se ejecuta por la \textbf{servlet engine} al descargarlo
\end{itemize}

\subsubsection{Http Servlet}
Se trata de un servlet específico para llamadas HTTP.

Define dos nuevos métodos: 'doGet' y 'doPost' que atienden a las peticiones HTTP GET y HTTP POST respectivamente. Ambos métodos se ejecutan desde el método 'service'.

\subsubsection{Crear un servlet}
Para crear un servlet debemos definir una subclase de javax.servlet.http.HttpServlet, implementar alguno de los métodos: 'doGet', 'doPost' o 'service' y dar de alta el servlet en el servidor de servlets.

\subsubsection{Ejecutar un servlet}
\begin{enumerate}
\item El cliente se conecta al servlet como URL
\begin{itemize}
\item Directamente tecleado en el navegador
\item En un enlace HTML ó desde un formulario HTML
\item En un objeto URL de java
\end{itemize}
\item El servlet se carga (en el servidor)
\begin{itemize}
\item Se carga la clase del servlet
\item Se crea una instancia
\end{itemize}
\item El servlet se arranca (en el servidor)
\begin{itemize}
\item Se ejecuta uno de sus métodos
\end{itemize}
\item El servlet termina
\item El cliente lee la salida del servlet, típicamente un string con código HTML para una página web
\end{enumerate}

\subsubsection{Comunicación entre cliente y servlet}
Se realiza por medio de Streams de entrada y salida.

La salida del servlet se emplea para generar páginas web que son enviadas al cliente. La salida del cliente hacia el servlet es menos frecuente; para enviar datos al servlet normalmente se utilizan parámetors.

\textbf{Parámetros HTTP:}

Se envían como parte del URL o con un formulario HTML

\subsubsection{HttpServletRequest}
Se trata de una clase java que representa la petición del cliente. Sus métodos principales son:
\begin{itemize}
\item getParameterNames(): Devuelve una enumeración con los
parámetros recibidos desde la página HTML.
\item getParameterValues(String name): Devuelve los valores de un parámetro multivalorado.
\item getParameter(String name): Devuelve el valor de un
parámetro simple.
\item getReader(): Devuelve un objeto de la clase BufferedReader para leer el cuerpo de la petición HTTP.
\end{itemize}

\subsubsection{HttpServletResponse}
Se trata de una clase java que proporciona el canal de comuncación de retorno con el cliente. Sus métodos principales son:
\begin{itemize}
\item setContentType(String type): Selecciona el tipo MIME de
la respuesta que se devuelve al cliente.
\item sendError(int sc): Devuelve el código de error sc al cliente.
\item sendRedirect(String URL): Redirige el navegador a la URL que se especifica como parámetro.
\item getWriter(): Devuelve un objeto de la clase PrintWriter
para realizar la salida de la página a enviar al cliente, mediante escritura en modo texto.
\item getOutputStream(): Devuelve un objeto de la clase
ServletOutputStream que permite devolver al cliente un
contenido binario.
\end{itemize}

\subsubsection{Gestión de la sesión}
Los servlets gestionan el estado de la sesión a través del objeto HttpSession.

Este objeto representa una conexión cliente-servidor cuya vida se alarga a través de múltiples invocaciones del cliente, incluso a distintos servlets. Se identifican a través de la consulta mediante un identificador de sesión.

El servlet accede a este objeto mediante el método 'getSession'.

Estas sesiones almacenan información específica de la aplicación como parejas clave-objeto a través de los métodos: 'setAttribute' y 'getAttribute'.

Los objetos que se almacenan deben ser serializables y es la \textbf{servlet engine} quien se encarga de establecer el método de identificarlos.

\subsubsection{¿Se debe sincronizar?}
Las especificaciones de Java dicen que no hace falta, puesto que no hay acceso concurrente cuando dos usuarios diferentes acceden a la misma página simultáneamente. Pero con Ajax, es posible que dos llamadas asíncronas del mismo usuario lleguen (casi) simultáneamente.

Por ello debemos tomar precauciones y no sincronizar sobre la instancia del servlet sino sobre la sesión.

\subsubsection{Servlet Context}
Dento de una \textbf{servlet engine} se almacena información asociada al servidor y a los servlets o a determinados grupos de servlets que se ejecutan.

Estos acceden a ell a traves de la clase ServletContext que contiene parámetros para la inicialización así como atributos.

El servlet puede almacenar y recuperar atributos a través de los métodos 'setAttribute' y 'getAttribute'.

\subsubsection{Request Dispatcher}
Se trata de una interfaz que permite a un servlet realizar consultas HTTP redirigiendo la consulta a una nueva URL (forwarding) o ejecutando la consulta y recuperando el control de nuevo tras su ejecución.

Se adqiere a través del contexto mediante el método 'getRequestDispatcher' y tiene dos métodos básicos para realizar los dos tipos de llamadas descritos que reciben como parámetros los mismos objetos que el servlet origen: 'forward' e 'inlcude'.

Ambos métodos permiten ir de un servlet/jsp a otra página web al final del procesamiento, pero son ligeramente distintos:
\begin{itemize}
\item \textbf{Forward}
Se ejecuta internamente sin que el navegador perciba el cambio. Por tanto la URL no cambia y cualquier recarga del navegador cargará la página original.
\item \textbf{Redirect}
Se trata de un proceso en dos pasos donde la aplicación web le indica al navegador que debe acceder a una segunda URL, distinta de la de origen. Una recarga nos mandaría a esa segunda URL.

Es algo más lengo que el 'forward' y los objetos disponibles en el request original no lo están en el segundo.
\end{itemize}

Se debe usar forward sólo si la operación del servlet puede ser repetida sin problemas, sino debe usarse redirect. En el contexto de una base de datos:
\begin{itemize}
\item Usar forward para operaciones SELECT de la base de datos.
– Y normalmente método GET de envío de datos
\item Usar redirect para operaciones INSERT, DELETE, UPDATE.
– Y normalmente método POST de envío de datos.
\end{itemize}

\subsubsection{Ejecución detallada de una petición a un servlet}
\begin{enumerate}
\item El cliente lo solicita mediante una URL con su nombre y clase
\begin{itemize}
\item http://miservidor/servlets/com.ibm.aplicacion.Servlet1
\item Algunos servidores admiten asignación de nombres a cada servlet para independizarlos del nombre de la clase.
\end{itemize}
\item El servidor detecta que se trata de un servlet y lo pasa a la servlet engine.
\item La servlet engine pasa esta información a un servlet especial, denominado invoker.
\item invoker comprueba si el servlet está cargado en memoria
\begin{itemize}
\item Si lo está, crea una nueva tarea (hilo) sobre la misma instancia.
\item Si no lo está, busca el objeto en el CLASSPATH, crea una nueva instancia, ejecuta su método init y ejecuta la petición.
\end{itemize}
\end{enumerate}

\subsection{JavaServer Pages (JSP)}
\begin{defn}[JSP]
Es una tecnología que ayuda a los desarrolladores de software a crear páginas web dinámicas basadas en HTML, XML, entre otros tipos de documentos. JSP es similar a PHP, pero usa el lenguaje de programación Java.
\end{defn}

Permite mezclar código HTMl y código Java, necesita un servidor web que lo soporte y se accede igual que a una página html desde un navegador. Se ejecutan en una \textbf{servlet engine (jsp engine)}

Las JSP son convertidas en un servlet dinámicamente la primera vez que se ejecutan y se crea un objeto que implemente la interfaz HttpJspPage.

Un archivo JSP contiene código HTML nativo, elementos de JSP (directivas o acciones estándar, elementos del lenguaje, etc).

\subsubsection{Objetos implícitos}
Hay una serie de objetos que siempre se encuentra definidos en una JSP sin necesidad de que los defina el usuarios. Los principales son:
\begin{itemize}
\item page: Representa la página jsp que se está ejecutando.
\item request: Consulta recibida del usuario (tipo HttpServletRequest).
\item response: Objeto para generación de resultado (tipo HttpServletResponse).
\item session: Sesión de trabajo del cliente (tipo HttpSession)
\item application: Contexto de los servlets (tipo ServletContext)
\item out: Permite la escritura en la página de salida (tipo JspWriter)
\item exception: En páginas de error, contiene la condición de error por la que se han ejecutado.
\end{itemize}

\subsubsection{Directivas y acciones}
\begin{itemize}
\item Directivas: Mensajes para la \textbf{jsp engine}
\begin{verbatim}
– <%@ page {atributo="valor"}* %>
Define propiedades generales de la página: lenguaje, Classpath,
herencia, imports...
– <%@ include file="nombre_archivo" %>
Orden de incluir un archivo en la página actual, en tiempo de
compilación.
– <%@ taglib uri="URI_archivo_etiquetas" %>
Referencia a un archivo con declaración de etiquetas de usuario.
\end{verbatim}
\item Aciones: Comandos a realizar en tiempo de ejecución
\begin{verbatim}
– <jsp:include page="URLrelativa" />
– <jsp:forward page="URLrelativa" />
  /*Los dos anteriores realizan una llamada al RequestDispatcher */
– <jsp:useBean id="nombre" scope="page|request|session|application"
class="nombreCompletoClase" />
Define para su uso en la página un javaBean con el nombre
"nombre".
– <jsp:setProperty name="nombre" property="propName"
value="valor"/>
Activa una propiedad del JavaBean "nombre".
– <jsp:getProperty name="nombre" property="propName" />
Recupera una propiedad del JavaBean "nombre" y la almacena en la
página.
\end{verbatim}
\end{itemize}

\subsubsection{Elementos del lenguaje}
\begin{verbatim}
Declaraciones de variables y métodos
– <%! declaracion %>
– Se pueden declarar aquí los métodos especiales
• jspInit(): Se ejecuta al iniciar la página JSP.
• jspDestroy(): Se ejecuta al destruir la página JSP.
Scriptlets: Contiene cualquier fragmento de código válido en lenguaje Java.
– <% fragmento_de_código %>
– El código introducido se copia al cuerpo del método del servlet compilado
Expresiones: Cualquier expresión Java válida
– <%= expresión %>
– En tiempo de ejecución:
• Se evalúa la expresión.
• El resultado se convierte a String.
• Se presenta en la página resultado.
\end{verbatim}

\subsubsection{Ejecución detallada de una petición de una JSP}
\begin{enumerate}
\item El cliente envía una petición.
\item El servidor detecta que la petición se resuelve mediante JSP.
\begin{itemize}
\item Pasa la petición a la servlet engine correspondiente.
\end{itemize}
\item La servlet engine comprueba si el archivo JSP está compilado.
\begin{itemize}
\item Si no lo está, lo compila mediante un servlet de compilación de páginas (PageCompileServlet, JspServlet)
\end{itemize}
\item La servlet engine pasa la petición al servlet invoker, que actúa como con cualquier otro servlet:
\begin{itemize}
\item Comprueba si está instanciado, y si no lo está, lo instancia y ejecuta su método init.
\item La servlet engine ejecuta el método correspondiente del servlet en una nueva tarea (hilo) para atender al servicio.
\end{itemize}

\end{enumerate}
\normalsize
\printindex
\end{document}
