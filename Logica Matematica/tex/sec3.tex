% -*- root: ../LogicaMatematica.tex -*-
\section{Computación}

\subsection{Motivación}

\paragraph{La ecuación diofántica:} $x^2+y^2=z^2$ tiene soluciones no triviales en enteros, por ejemplo, $x=3, y=4, z=5$. Si generalizamos esta ecuación escribiendo $x^n+y^n = z^n$, para $n>2$, podemos ver que tiene soluciones triviales ($x=y=z=0$). No obstante, es sabido que en este segundo caso la ecuación no tiene soluciones no triviales en enteros (Wiles, 1995).

\paragraph{X problema de Hilbert:} Este problema consiste en hallar un algoritmo que, dada cualquier ecuación diofántica, nos diga si esta tiene soluciones en enteros o no.

Es decir, dado cualquier polinomio con coeficientes en $\mathbb{Z}$, dependiente de cualquier número de variables, $x_1,\hdots, x_m$, el algoritmo decide si $p(x_1, \hdots, x_m)=0$ tiene soluciones en enteros o no.

\obs Se pide \textbf{un sólo algoritmo} que debe funcionar para todas las ecuaciones diofánticas.


En 1970, Yuri Matiyasevich, basándose en trabajos previos de Martin Davies, Hilary Putnam y Julia Robinson, demostró que no existe tal algoritmo.


Informalmente, el teorema de incompletitud de Gödel nos dice que dada cualquier axomatización (computable) de la aritmética, la teoría resultante es incompleta. Más precisamente, tenemos:

\begin{theorem}[]
Sea $\algb{N} = (ℕ,0,s,+,·,<)$ el modelo estándar de los  naturales y sea $Σ$ una teoría axiomatizable de sentencias verdaderas en $\mathcal{N}$.

\textbf{Entonces} existe una sentencia $σ$ tal que $Σ \vDash σ$ pero $Σ\nvdash σ$, con lo que $Σ$ es incompleta.

\end{theorem}

\obs Como la teoría $Σ$ tiene un modelo, no podemos derivar contradicciones, es decir, es consistente.

\begin{proof}
Sistemáticamente obtenemos todas las consecuencias lógicas de la teoría.

Dada cualquier ecuación diofántica $p(x_1,...,x_n) = 0$, si $Σ$ fuese completa, tras un número finito de pasos obtendríamos
\[Σ\vdash ∃x_1,...,x_n p(x_1,...,x_n) = 0 \text{ ó } Σ\vdash \nexists x_1,...,x_n p(x_1,...,x_n) = 0\]

Y resolveríamos el $X$-problema de Hilbert afirmativamente.

Y como el $X$-problema de Hilbert no tiene solución, deducimos que $Σ$ no es completa.
\end{proof}

% \begin{example}
% Vamos a definir $f:ℚ\to ℕ^2$ de la forma: $f\left(\frac{a}{b}\right) = (a,b)$ y el siguiente paso es definir la inyección en $ℕ$:

%\textcolor{red}{dibujo}

%\end{example}
\begin{example}
Sea $x^3 + y^3 = z^3$

Podríamos ir intentando probar con
\[(x,y,z) = (1,1,1) \to (1,1,2) \to (1,1,3) \to ... \to (1,1,n)\]
pero este sistema no es muy bueno ya que hay combinaciones que nunca llegaríamos a probarcomo $(2,1,1)$.

Lo que habría que hacer sería es probar las combinaciones posibles de la forma:
\[(x,y,z) = (1,1,1) \to (1,1,2) \to (1,2,1) \to (1,2,2) \to (2,1,1) \to (2,1,2) \to ...\]
Este si sería un procedimiento que nos asegura pasar por todas las posibilidades y que si existe una solución la encontramos en un número $n$ finito de pasos.
\end{example}

\obs Si $Σ$ es suficientemente rica como para contener los resultados básicos sobre sumas y productos (por ejemplo si contiene los axiomas $N1 - N9$ del libro), si $p(x_1,...,x_n) = 0$ para alguna $n$-tupla $a_1,...,a_n$ , entonces $Σ\vdash ∃x_1,...,x_n p(x_1,...,x_n ) = 0$.

Es decir, siendo Σ lo bastante rica, en caso de existir solución de una ecuación diofántica de $n$ variables, podremos demostrar la existencia de la solución a partir de Σ.

%En el argumento anterior (idea de la prueba del teorema), podemos tomar $σ = \nexists x_1,...,x_n p(x_1,...,x_n) = 0$ para alguna ecuación diofántica.

%En este caso, $\mathcal{N}\vDash σ, \text{ pero } Σ \nvdash σ$ ($σ$ depende de $Σ$).

\subsection{Máquinas de Turing}

Es importante, antes de saber lo que son las máquinas de Turing, saber que Turing se pronucia ``tiuring''.

\begin{example}
Para comprender el funcionamiento de las máquinas de Turing vamos a computar la suma $15 + 267$, sumando en columna:

\[
\begin{array}{cccc}
&&1&5\\
&2&6&7\\\hline
&&&
\end{array}
\]

\begin{enumerate}
	\item Veo un 5. Lo guardo en mi memoria y bajo.
	\item Veo un 7. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 2) y vacío mi memoria. Si hay más dígitos, los almaceno en mi memoria (en este caso un 1).
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un 1. Lo guardo en mi memoria y bajo.
	\item Veo un 6. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 8) y vacío mi memoria. BO hay más dígitos.
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un hueco. Bajo
	\item Veo un 2. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 2) y vacío mi memoria. BO hay más dígitos.
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un hueco. Bajo.
	\item Veo un hueco. Bajo.
	\item Veo un hueco. Bajo.
	\item Voy arriba del todo y he acabado.
\end{enumerate}
\end{example}

\begin{defn}[Máquinas de Turing]
Variantes (que dan lugar al mismo modelo de computación) que cumplen:

\begin{itemize}
	\item El modelo ideal de computación sin limitaciones de tiempo ni de espacio.
	\item La condición ``bidimensional'' del papel cuadriculado no es esencial. Consideramos una cinta infinita en ambas direcciones con casillas:
	\begin{center}
	\begin{tabular}{|c|c|c|c|}
	\hline
	&&&...\\
	\hline
	\end{tabular}
	\end{center}
	\item En las casillas encontramos símbolos pertenecientes a un alfabeto finito $S$. (En la actualidad, ese alfabeto finito sólo tiene 2 símbolos: $0$ y $1$, ya que todos los demás se pueden traducir en esos símbolos). En lugar de $0$, a veces utilizaremos $B$ denotando ``espacio en blanco''.
	\item La máquina tiene un cabezal que lee los contenidos de la celda. Puede modificarlos o dejarlos igual.
	\item Puede desplazarse a la casilla de la izquierda o a la de la derecha.
	\item La acción de una máquina de Turing depende únicamente de el contenido de la casilla que está leyendo y de su estado interno.
	\item La computación se inicia con el cabezal sobre la casilla con el primer $1$.
	\item Denotaremos los estados por $q_0, q_1, \hdots$.
\end{itemize}

\textbf{Acciones:}
\begin{itemize}
	\item Acción $B$: Si la casilla que está leyendo tiene una $B$ o un $1$, la máquina borra y escribe $B$.
	\item Acción $1$: La máquina borra y escribe un $1$.
	\item Acción $D$: El cabezal puede moverse una casilla a la derecha.
	\item Acción $I$: El cabezal puede moverse una casilla a la izquierda.
\end{itemize}

Un paso de la Máquina de Turing viene especificado por una cuaterna
$$\left(q_i, S, A, q_j\right)$$
donde
\begin{itemize}
	\item $q_i$: Estado inicial.
	\item $S$: Símbolo.
	\item $A$: Acción que toma.
	\item $q_j$: Siguiente estado.
\end{itemize}

Una máquina de Turing viene definida por un número finito de cuaternas con la propiedad de que dos cuaternas distintas no pueden tener los dos primeros símbolos iguales.
\end{defn}

\begin{example}
	Consideramos la siguiente máquina de Turing:
	\begin{enumerate}
		\item $(q_0, 1, B, q_1)$
		\item $(q_1, 1, D, q_0)$
	\end{enumerate}

	Si esta máquina recibe el siguiente input
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
			\hline
			B & B & 1 & 1 & 1 & B & 1 & B & B & B & $\hdots$\\
			\hline
		\end{tabular}
	\end{center}

	Se coloca en el estado $q_0$ y coloca el cabezal en la primera casilla con un 1 en ella.

	Tras esto comienza a trabajar siguiendo las reglas que tiene definidas.
	\begin{enumerate}
		\item \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
			\hline
			B & B & B & 1 & 1 & B & 1 & B & B & B & $\hdots$\\
			\hline
		\end{tabular}\\
		\begin{tabular}{c c c c c c c c c c c }
			&  &  & \ $\uparrow$ & \ $\uparrow$  &  &  &  &  &  & \\
			&  &  & $q_1$ & $q_0$  &  &  &  &  &  & \\
		\end{tabular}
		\item \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
			\hline
			B & B & B & B & B & B & 1 & B & B & B & $\hdots$\\
			\hline
		\end{tabular}\\
		\begin{tabular}{c c c c c c c c c c c }
			&  &  &  &  &  &  &  & \ $\uparrow$ &  & \\
			&  &  &  &  &  &  &  & $q_0$ &  & \\
		\end{tabular}

		Como no hay ninguna cuaterna $(q_0, B, \hdots)$, la máquina se detiene.
	\end{enumerate}
\end{example}

\begin{example}
	Extendemos el alfabeto a $S=\{B, 1, +\}$
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			\hline
			B & 1 & 1 & 1 & $+$ & 1 & 1 & B & $\hdots$\\
			\hline
		\end{tabular}

	\begin{tabular}{c c c c c c c c c c c}
		  \ $\uparrow$ &  &  &  &  &  & &  & &&  \\
		  $q_0$ &  &  &  &  &  &  &  & & &\\
	\end{tabular}
	\end{center}

	La máquina de Turing es
	\begin{itemize}
		\item $(q_0, 1, B, q_0)$
		\item $(q_0, B, D, q_1)$
		\item $(q_1, 1, D, q_1)$
		\item $(q_1, +, 1, q_2)$
	\end{itemize}

	El estado final es
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			\hline
			B & B & 1 & 1 & 1 & 1 & 1 & B & $\hdots$\\
			\hline
		\end{tabular}

		\begin{tabular}{c c c c c c c c c c c}
			&  &  &  &  & $\uparrow$ &  & & & & \\
			&  &  &  & &  $q_2$  &  &  & & & \\
		\end{tabular}
	\end{center}

	La máquina ha sumado $3+2$, increíble.
\end{example}

\paragraph{Test de Church-Turing} \mbox{}

Sea una función $f:A\subset\nat^k\to \nat$ calculable mediante un algoritmo. La clase (informal) de todas las funciones $f$ coincide exactamente con la clase de las funciones recursivas, o equivalentemente, con las funciones cuyos valores pueden calcularse por MT.


\begin{theorem}
	Las funciones $f:A\subset\nat^k\to \nat$ $(k=0,1,2,\hdots)$, calculables por MT son exactamente las funciones recursivas.
\end{theorem}

\begin{example}[Uso de la tesis de Church.]
	Los primos $P$ forman un conjunto recursivo, o equivalentemente, hay una MT que determina, para cada $n\ge2$, si $n\in P$ o $n\in P^c$.

	Veamos como podemos demostrarlo.

	Dado $n$, calculamos $\frac{n}{m}$ para todo $2\le m\le \sqrt{n}$. Si algún resto da $0$, entonces $n\in P^c$. Si no, $n\in P$.

	Como acabamos de comprobar que existe un algoritmo, por las tesis de Church-Turing, hay una MT que decide si $n\in P$ o $n\in P^c \forall n\ge 2$.

	Lo que hemos hecho no ha sido una demostración propiamente dicha pues esto implicaría dar una lista de cuaternas que deciden si $n\in P$  $n\notin P$.
\end{example}

Invocar la tesis de Church-Turing no prueba nada, pero con frecuencia puede ser reemplazada de manera rutinaria por una demostración formal.

Consideramos funciones parciales y funciones de $A\subset\mathbb{N}^k\to \mathbb{N}$ con $k\ge 0$.

\begin{defn}[Función\IS recursiva]
	$F=\{f:A\subseteq\mathbb{N}^k\to\mathbb{N}\tq k=0,1,2,\hdots\}$.
	Recordatorio: las constantes son las funciones $0-$arias.
	Una función $k-$aria con $k\ge 1$ también puede ser constante.
	Los elementos de $F$ son las \underline{funciones parciales}. Si $f\in F$ y $A=\mathbb{N}^k$, entonces $f$ es una \underline{función total}.
\end{defn}

\begin{defn}[Función\IS recursiva primitiva]
	Las funciones recursivas primitivas (son totales) forman la subclase $E$ más pequeña de $F$, cerrada bajo las siguientes operaciones:
	\begin{itemize}
		\item Las funciones constantes $k-$arias $f:\mathbb{N}^k\to\mathbb{N}$ $(\forall x_1, \hdots, x_k, f(x_1, \hdots, x_k)=c)$ pertenecen a $E$.
		\item Las proyecciones sobre las coordenadas (o funciones coordenadas) están en $E$. Es decir, para $k=1,2,\hdots$, $\pi_{k,i}(x_1, \hdots, x_k)=x_i$, está en $E$.
		\item Las funciones sucesor $S\in E$ ($S(n) = n+1$).
		\item La clase $E$ está cerrada por composición.
		\item La clase $E$ está cerrada bajo definiciones por recurrencia (o por recursión primitiva, o por ``inducción'').
	\end{itemize}
\end{defn}

\begin{defn}
	Definimos la función $h:A\subset\mathbb{N}^k\to\mathbb{N}$ por recurrencia a partir de $f:B\subset\nat^k\to \nat$ y $g:C\subset\nat^{k+2}\to\nat$ (aquí, si $\exists x_{k+1}$ tal que $(x_1, \hdots, x_k, x_{k+1})\in A$, entonces $(x_1, \hdots, x_k)\in B$, y $C=A\times\nat)$ mediante:
	\begin{enumerate}
		\item $h(x_1,\hdots, x_k,0)=f(x_1, \hdots, x_k)$
		\item $h(x_1, \hdots, x_{k}, n+1) = g(x_1, \hdots, x_k,n,h(x_1,\hdots, x_k, n))$
	\end{enumerate}
\end{defn}

\begin{example}
	La función suma $+:\nat^2\to\nat$ es  recursiva primitiva. Por recurrencia definimos:
	\begin{enumerate}
		\item $+(x,0) = \pi_{1,1}(x) = x$
		\item $+(x,n+1) =  S(\pi_{3,3}(x,n,+(x,n))) = x+n+1$
	\end{enumerate}
\end{example}

O más simplemente (e informalmente):
\begin{enumerate}
	\item $x+0 = x$
	\item $x+(n+1) = (x+n) +1$
\end{enumerate}
\begin{example}
	El producto $\cdot:\nat^2\to \nat$ es una función recursiva primitiva. Definimos inductivamente:
	\begin{enumerate}
		\item $x\cdot 0 = 0$
		\item $x\cdot(n+1) = x\cdot n + x$
	\end{enumerate}
\end{example}


\begin{example}
La exponenciación $\appl{ \textasciicircum }{\nat\times \nat}{\nat}$ es una función recursiva primitiva. Por recurrencia definimos
\begin{enumerate}
\item $x^0=1$
\item $x^{y+1} = x^y\cdot x$
\end{enumerate}
\end{example}

\begin{example}
La operación ``signo'' es también una funación recursiva. Definimos inductivamente:
\begin{enumerate}
\item $\text{signo}(x)=1$ si $x>0$
\item $\text{signo}(0)=0$
\end{enumerate}
\end{example}

\begin{defn}[Conjunto recursivo primitivo]
Un conjunto $A \subset \nat^k$ es recursivo primitivo si y sólo si la función indicatriz evaluada sobre este conjunto es primitiva.
\end{defn}

\begin{defn}[Relación $k$-aria recursiva primitiva]
Una relación $k$-aria $\algb{R} \subset \nat^k$ es recursiva  si y sólo si el conjunto $\{(x_1,...,x_r)\in \algb{R}\}$ es recursivo primitivo.
\end{defn}

Veamos algunos ejemplos conjntos y relaciones recursivas primitivas.
\begin{example}
\begin{enumerate}
\item $\forall k \geq 1$ el conjunto $\nat^k$ es un conjunto recursivo primitivo pues la función indicatriz sobre este conjunto es la constante 1 y sabemos que las funciones constantes son recursivas primitivas.

\item Si $A$ es recursivo primitivo, también lo es $A^c$.

Para comprobarlo basta con notar que:
\[\ind_{A^c} = \max\{\ind_{\nat^k}-\ind_{A},0\}\]
que sabemos es también una función recursiva primitiva.

\item La relación $\algb{R}(x,y) \iff x>y$ es recursiva primitiva.

Para comprobarlo debemos ver que el conjunto $A=\{(x,y) \in \nat^2, \ x>y\} $ es recursivo primitivo.

Esto es sencillo puesto que:
\[\ind_A = \text{signo}\left(\max\{x-y,0\}\right)\]

\item La relación $x\geq y$ es recursiva primitiva como podemos comprobar definiendo
\[\ind_A = \text{signo}\left(\max\{x-y+1,0\}\right)\]

\item Si una función $f$ se define por casos (un número finito de casos) usando funciones recursivas primitivas, entonces $f$ es recursiva primitiva.
\end{enumerate}
\end{example}

Las funciones primitivas no incluyen a todas las funciones calculables mediante un algoritmo. Como ejemplo tenemos la \textbf{función de AcKermann} (ver páginas 89-01 del libro).

\subsection{Minimización no acotada y funciones recursivas}
Vamos a matizar un poco la definición que hemos visto de funciones recursivas.

\begin{defn}[Función recursiva]
Las funciones recursivas son la clase $E'\subset F$ más pequeña que contiene a las constantes, a las proyecciones sobre las coordenadas, a $S$ y está cerrada por composición, recurrencia y minimización no acotada.
\end{defn}

\begin{defn}[Minimización no acotada]
Sea $f\in F$ una función $(k+1)$-aria, definimos la funci'on
\[g(x_1,...,x_k)=μz\left(f(x_1,...,x_k,z=0)\right)= \min\{z \in \nat f(x_1,...,x_k,z)=0\}\]

Si el valor $z \in \nat$ empleado en la definición no existe entonces $g$ no está definida en $(x_1,...,x_k)$.

A esta forma de generar nuevas funciones se le denomina \textbf{minimización no acotada}

\end{defn}

\begin{defn}[Conjunto recursivo]
Un conjunto $A \subset \nat^k$ es recursivo si y sólo si $\ind_A$ es \textbf{recursiva total}
\end{defn}

\begin{defn}[Conjunto recursivamente enumberable]
Un conjunto $A \subset \nat^k$ es recursivamente enumerable si es el dominio de una función recursiva (parcial o total).
\end{defn}